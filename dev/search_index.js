var documenterSearchIndex = {"docs":
[{"location":"materials/","page":"Materials","title":"Materials","text":"CurrentModule = Cthonios","category":"page"},{"location":"materials/#Materials","page":"Materials","title":"Materials","text":"","category":"section"},{"location":"materials/","page":"Materials","title":"Materials","text":"Cthonios utilizes ConstitutiveModels.jl as a material model backend.","category":"page"},{"location":"materials/","page":"Materials","title":"Materials","text":"Here is an example for how to define multiple materials within an input file","category":"page"},{"location":"materials/","page":"Materials","title":"Materials","text":"materials:\n  metal_linear:\n    model: LinearElastic\n    properties:\n      youngs modulus: 1.0\n      poissons ratio: 0.3\n  soft rubber:\n    model: NeoHookean\n    properties:\n      bulk modulus: 50.0\n      shear modulus: 1.0","category":"page"},{"location":"materials/#Useful-methods","page":"Materials","title":"Useful methods","text":"","category":"section"},{"location":"materials/","page":"Materials","title":"Materials","text":"TODO","category":"page"},{"location":"sections/","page":"Sections","title":"Sections","text":"CurrentModule = Cthonios","category":"page"},{"location":"sections/#Sections","page":"Sections","title":"Sections","text":"","category":"section"},{"location":"sections/","page":"Sections","title":"Sections","text":"Within Cthonios, sections refer to groups or \"blocks\" of elements that share a common element topology and material model. We allow by default for each element to possess different fixed material properties and an arbitrary number of state variables. Since the material model is the same for all elements in a section, the number of state variables will be the same at each element/quadrature point.","category":"page"},{"location":"sections/#Input-file-syntax","page":"Sections","title":"Input file syntax","text":"","category":"section"},{"location":"sections/","page":"Sections","title":"Sections","text":"TODO","category":"page"},{"location":"sections/","page":"Sections","title":"Sections","text":"Modules = [Cthonios]\nPages = [\"Sections.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"sections/#Cthonios.AbstractSection","page":"Sections","title":"Cthonios.AbstractSection","text":"abstract type AbstractSection\n\nAbstract base type for sections (both for input and internal).\n\n\n\n\n\n","category":"type"},{"location":"sections/#Cthonios.AbstractSectionInput","page":"Sections","title":"Cthonios.AbstractSectionInput","text":"abstract type AbstractSectionInput <: Cthonios.AbstractSection\n\nAbstract type for section inputs.\n\n\n\n\n\n","category":"type"},{"location":"sections/#Cthonios.AbstractSectionInternal","page":"Sections","title":"Cthonios.AbstractSectionInternal","text":"abstract type AbstractSectionInternal{F, P} <: Cthonios.AbstractSection\n\nAbstract type for section internals. P corresponds to the physics F corresponds to the formulation\n\n\n\n\n\n","category":"type"},{"location":"sections/#Cthonios.NeumannBCSectionInternal","page":"Sections","title":"Cthonios.NeumannBCSectionInternal","text":"struct NeumannBCSectionInternal{F, P<:Cthonios.AbstractPhysics, M, B} <: Cthonios.AbstractSectionInternal{F, P<:Cthonios.AbstractPhysics}\n\nblock_id::Int64\nq_order::Int64\nfspace::Any\nphysics::Cthonios.AbstractPhysics\nprops::Any\nbc::Any\n\nSection internals. physics - Physics object to use in this section. block_name - Name of exodus block to construct section from. fspace - Function space for this element type\n\n\n\n\n\n","category":"type"},{"location":"sections/#Cthonios.Section","page":"Sections","title":"Cthonios.Section","text":"struct Section{P, M} <: Cthonios.AbstractSectionInput\n\nblock_name::String\nq_order::Int64\nphysics::Any\nprops::Any\n\nSection inputs. physics - Physics object to use in this section. block_name - Name of exodus block to construct section from. q_order - Quadrature Order to use\n\n\n\n\n\n","category":"type"},{"location":"sections/#Cthonios.SectionInternal","page":"Sections","title":"Cthonios.SectionInternal","text":"struct SectionInternal{F, P<:Cthonios.AbstractPhysics, M} <: Cthonios.AbstractSectionInternal{F, P<:Cthonios.AbstractPhysics}\n\nblock_id::Int64\nq_order::Int64\nfspace::Any\nphysics::Cthonios.AbstractPhysics\nprops::Any\n\nSection internals. physics - Physics object to use in this section. block_name - Name of exodus block to construct section from. fspace - Function space for this element type\n\n\n\n\n\n","category":"type"},{"location":"sections/#Cthonios.SectionInternal-Tuple{Any, FiniteElementContainers.DofManager, Any}","page":"Sections","title":"Cthonios.SectionInternal","text":"SectionInternal(\n    mesh,\n    dof::FiniteElementContainers.DofManager,\n    section\n) -> Cthonios.SectionInternal{F} where F<:(FiniteElementContainers.NonAllocatedFunctionSpace{_A, _B, FiniteElementContainers.VectorizedElementField{T, N, NN, NE, Vals}, _C, ReferenceFiniteElements.ReferenceFE{Itype, Ftype, Etype, SEType, Backend, EdgeNodes, FaceNodes, InteriorNodes, Coords, CellInterps, SurfaceCoords, SurfaceInterps}} where {_A, _B, T, N, NN, NE, Vals<:AbstractVector{T}, _C<:(FiniteElementContainers.ElementField), Itype, Ftype, Etype, SEType, Backend, EdgeNodes, FaceNodes, InteriorNodes, Coords, CellInterps, SurfaceCoords, SurfaceInterps})\n\n\nConstructor for SectionInternal. mesh - FileMesh object. dof - DofManager object. section - SectionInput object.\n\n\n\n\n\n","category":"method"},{"location":"sections/#Base.size-Tuple{Cthonios.AbstractSectionInternal}","page":"Sections","title":"Base.size","text":"size(\n    section::Cthonios.AbstractSectionInternal\n) -> NTuple{4, Any}\n\n\nRetrieves the sizes of a section in the following tuple (ND, NN, NP, NS) where ND - Number of dimensions NN - Number of nodes per element NP - Number of properties NS - Number of states\n\n\n\n\n\n","category":"method"},{"location":"sections/#Cthonios.num_fields-Tuple{Cthonios.AbstractSection}","page":"Sections","title":"Cthonios.num_fields","text":"num_fields(section::Cthonios.AbstractSection) -> Any\n\n\nRetrieves the number of fields for the physics in section\n\n\n\n\n\n","category":"method"},{"location":"sections/#Cthonios.num_properties-Tuple{Cthonios.AbstractSection}","page":"Sections","title":"Cthonios.num_properties","text":"num_properties(section::Cthonios.AbstractSection) -> Any\n\n\nRetrieves the number of properties for the physics in section\n\n\n\n\n\n","category":"method"},{"location":"sections/#Cthonios.num_states-Tuple{Cthonios.AbstractSection}","page":"Sections","title":"Cthonios.num_states","text":"num_states(section::Cthonios.AbstractSection) -> Any\n\n\nRetrieves the number of states for the physics in section\n\n\n\n\n\n","category":"method"},{"location":"domains/","page":"Domains","title":"Domains","text":"CurrentModule = Cthonios","category":"page"},{"location":"domains/#Domains","page":"Domains","title":"Domains","text":"","category":"section"},{"location":"domains/","page":"Domains","title":"Domains","text":"A domain in Cthonios is a group of element sections and all the associated datastructures necessary to run a finite element calculation. Different types of domains are used for different problems, e.g. quasi-static vs. dynamics problems have different requirements and solution strategies.","category":"page"},{"location":"domains/#Input-file-syntax-example","page":"Domains","title":"Input file syntax example","text":"","category":"section"},{"location":"domains/","page":"Domains","title":"Domains","text":"domains:\n  domain_1:\n    mesh:\n      ...\n    boundary conditions:\n      ...\n    sections:\n      ...\n    time stepper:\n      ...","category":"page"},{"location":"domains/#Quasi-static-Domain","page":"Domains","title":"Quasi-static Domain","text":"","category":"section"},{"location":"domains/","page":"Domains","title":"Domains","text":"Quasi-static domains are appropriate for problems where the following equation holds","category":"page"},{"location":"domains/","page":"Domains","title":"Domains","text":"nablacdot mathbfP + mathbfb = mathbf0 where mathbfP is the first Piola-Kirchoff stress, nabla is the gradient operator with respsect to the reference corrdinates, and mathbfb is a body force.","category":"page"},{"location":"domains/#Index","page":"Domains","title":"Index","text":"","category":"section"},{"location":"domains/","page":"Domains","title":"Domains","text":"Modules = [Cthonios]\nPages = [\"Domains.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"domains/#Cthonios.AbstractDomain","page":"Domains","title":"Cthonios.AbstractDomain","text":"abstract type AbstractDomain\n\nAbstract base type for domains.\n\n\n\n\n\n","category":"type"},{"location":"domains/#Cthonios.Domain","page":"Domains","title":"Cthonios.Domain","text":"struct Domain{C, D, S, DBCs, DDofs, NBCs, NS} <: Cthonios.AbstractDomain\n\ncoords::Any\ndof::Any\nsections::Any\ndirichlet_bcs::Any\ndirichlet_dofs::Any\nneumann_bcs::Any\nneumann_bc_sections::Any\n\nDomain type to hold information like bcs, sections, etc. Note that the DofManager unknown dofs are not automatically set. After setting up a Domain you will need to run, update_unknown_dofs!.\n\nmesh - Handle to an open FileMesh. dof - DofManager object. sections - A set of SectionInternals. dirichlet_bcs - A set of DirichletBCInternals. dirichlet_dofs - A set of dofs to apply dirichlet dofs.   This is mainly for book-keeping purposes\n\n\n\n\n\n","category":"type"},{"location":"domains/#Cthonios.Domain-Tuple{String, Any, Any, Any, Int64}","page":"Domains","title":"Cthonios.Domain","text":"Domain(\n    mesh_file::String,\n    sections_in,\n    dbcs_in,\n    nbcs_in,\n    n_dofs::Int64\n) -> Domain{C, D, S, DBCs, Vector{Int64}, NBCs, NS} where {C<:(FiniteElementContainers.VectorizedNodalField{_A, 2, _B, _C, _D} where {_A, _B, _C, _D<:AbstractVector{_A}}), D<:(FiniteElementContainers.DofManager{Int64, _A, _B, Vector{Float64}, _C} where {_A, _B, _C<:(AbstractArray{Int64})}), S<:NamedTuple, DBCs<:NamedTuple, NBCs<:NamedTuple, NS<:NamedTuple}\n\n\nConstructor for a Domain type. mesh_file - File name of a mesh to read. sections_in - A set of Sections. dbcs_in - A set of DirichletBCs. n_dofs - The number of dofs in the problem.\n\n\n\n\n\n","category":"method"},{"location":"domains/#Cthonios.DynamicAssembler-Tuple{Domain}","page":"Domains","title":"Cthonios.DynamicAssembler","text":"DynamicAssembler(\n    domain::Domain\n) -> FiniteElementContainers.DynamicAssembler{Float64, Int64, _A, _B, _C, _D, _E, _F, _G, _H, _I, _J, _K, _L, Vector{Int64}, Vector{Int64}, Vector{Float64}} where {_A<:AbstractVector{Int64}, _B<:AbstractVector{Int64}, _C<:AbstractVector{Int64}, _D<:AbstractVector{Int64}, _E<:AbstractVector{Int64}, _F<:FiniteElementContainers.NodalField, _G<:AbstractVector{Float64}, _H<:AbstractVector{Float64}, _I, _J, _K, _L}\n\n\nsome FEMContainers abuse\n\n\n\n\n\n","category":"method"},{"location":"domains/#Cthonios.StaticAssembler-Tuple{Domain}","page":"Domains","title":"Cthonios.StaticAssembler","text":"StaticAssembler(\n    domain::Domain\n) -> FiniteElementContainers.StaticAssembler{Float64, Int64, _A, _B, _C, _D, _E, _F, _G, _H, _I, _J, _K, Vector{Int64}, Vector{Int64}, Vector{Float64}} where {_A<:AbstractVector{Int64}, _B<:AbstractVector{Int64}, _C<:AbstractVector{Int64}, _D<:AbstractVector{Int64}, _E<:AbstractVector{Int64}, _F<:FiniteElementContainers.NodalField, _G<:AbstractVector{Float64}, _H, _I, _J, _K}\n\n\nsome FEMContainers abuse\n\n\n\n\n\n","category":"method"},{"location":"domains/#Cthonios.create_fields-Tuple{Domain}","page":"Domains","title":"Cthonios.create_fields","text":"create_fields(domain::Domain) -> Any\n\n\nCreate a zero field based on domain.dof.\n\n\n\n\n\n","category":"method"},{"location":"domains/#Cthonios.create_unknowns-Tuple{Domain}","page":"Domains","title":"Cthonios.create_unknowns","text":"create_unknowns(domain::Domain) -> Any\n\n\nCreates an unknown vector based on domain.dof\n\n\n\n\n\n","category":"method"},{"location":"domains/#Cthonios.dirichlet_dofs-Tuple{Domain}","page":"Domains","title":"Cthonios.dirichlet_dofs","text":"dirichlet_dofs(domain::Domain) -> Any\n\n\nReturns a sorted and unique vector of dirichlet dofs.\n\n\n\n\n\n","category":"method"},{"location":"domains/#Cthonios.update_dirichlet_vals!-Tuple{Any, Domain, Any, Any}","page":"Domains","title":"Cthonios.update_dirichlet_vals!","text":"update_dirichlet_vals!(Ubc, domain::Domain, X, t)\n\n\nUpdates the values in Ubc with dirichlet boundary conditions in domain. Ubc - BC values to fill. domain - Domain. X - Nodal coordinates. t - A scalar time value to use in the BC functions.\n\n\n\n\n\n","category":"method"},{"location":"domains/#Cthonios.update_field_bcs!-Tuple{Any, Domain, Any}","page":"Domains","title":"Cthonios.update_field_bcs!","text":"update_field_bcs!(U, domain::Domain, Ubc)\n\n\nUpdates the Dirichlet BC dofs in U with the values in Ubc. U - Nodal field to update. domain - Domain. Ubc - BC values to fill.\n\n\n\n\n\n","category":"method"},{"location":"domains/#Cthonios.update_field_unknowns!-Tuple{Any, Domain, Any}","page":"Domains","title":"Cthonios.update_field_unknowns!","text":"update_field_unknowns!(U, domain::Domain, Uu)\n\n\nUpdates the unknown dofs in U with the values in Uu. U - Nodal field to update. domain - Domain. Uu - Unknown values to fill.\n\n\n\n\n\n","category":"method"},{"location":"domains/#Cthonios.update_unknown_dofs!-Tuple{Domain, Any}","page":"Domains","title":"Cthonios.update_unknown_dofs!","text":"update_unknown_dofs!(domain::Domain, asm)\n\n\nUpdate the unknown dofs in domain.dof,  domain.dirichlet_dofs, and asm. TODO maybe move domain.dirichlet_dofsto theDofManagerinFiniteElementContainers.domain- Domain object.asm` - Assembly object.\n\n\n\n\n\n","category":"method"},{"location":"domains/#Cthonios.update_unknown_dofs!-Tuple{Domain}","page":"Domains","title":"Cthonios.update_unknown_dofs!","text":"update_unknown_dofs!(domain::Domain)\n\n\nUpdate the unknown dofs in domain.dof and domain.dirichlet_dofs. TODO maybe move domain.dirichlet_dofsto theDofManagerinFiniteElementContainers`.\n\n\n\n\n\n","category":"method"},{"location":"linear_solvers/","page":"Linear solvers","title":"Linear solvers","text":"CurrentModule = Cthonios","category":"page"},{"location":"linear_solvers/#Linear-Solvers","page":"Linear solvers","title":"Linear Solvers","text":"","category":"section"},{"location":"linear_solvers/","page":"Linear solvers","title":"Linear solvers","text":"This section describes the interface for linear solvers.","category":"page"},{"location":"linear_solvers/#Input-File-Syntax-Example","page":"Linear solvers","title":"Input File Syntax Example","text":"","category":"section"},{"location":"linear_solvers/","page":"Linear solvers","title":"Linear solvers","text":"Below is an example input file block for a direct solver with an LDLT factorization.","category":"page"},{"location":"linear_solvers/","page":"Linear solvers","title":"Linear solvers","text":"linear solvers:\n  direct:\n    type: DirectLinearSolver\n    factorization method: ldl","category":"page"},{"location":"linear_solvers/#General-methods-and-abstract-types","page":"Linear solvers","title":"General methods and abstract types","text":"","category":"section"},{"location":"linear_solvers/","page":"Linear solvers","title":"Linear solvers","text":"Modules = [Cthonios]\nPages = [\"solvers/linear_solvers/LinearSolvers.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"linear_solvers/#Cthonios.AbstractLinearSolver","page":"Linear solvers","title":"Cthonios.AbstractLinearSolver","text":"abstract type AbstractLinearSolver\n\nA linear solver simply needs to define the following methods\n\nresidual_norm\nsolve!\n\nsolve! method which has the following signature solve!(ΔUu, solver::DirectSolver, obj, Uu, p) where ΔUu is the increment for a nonlinear solver solver is the solver, obj is the objective, Uu is the current guess of the solution, and p is the set of parameters\n\n\n\n\n\n","category":"type"},{"location":"linear_solvers/#Direct-Solver","page":"Linear solvers","title":"Direct Solver","text":"","category":"section"},{"location":"linear_solvers/","page":"Linear solvers","title":"Linear solvers","text":"Modules = [Cthonios]\nPages = [\"solvers/linear_solvers/DirectSolver.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"linear_solvers/#Cthonios.DirectSolver","page":"Linear solvers","title":"Cthonios.DirectSolver","text":"assembler::Any\nlinsolve::Any\ntimer::Any\n\nDirect linear solver\n\n\n\n\n\n","category":"type"},{"location":"linear_solvers/#Cthonios.DirectSolver-Tuple{Dict{Symbol, Any}, Objective, Any, Any}","page":"Linear solvers","title":"Cthonios.DirectSolver","text":"DirectSolver(\n    inputs::Dict{Symbol, Any},\n    obj::Objective,\n    p,\n    timer\n) -> DirectSolver{A, L} where {A<:(FiniteElementContainers.StaticAssembler{Float64, Int64, _A, _B, _C, _D, _E, _F, _G, _H, _I, _J, _K, Vector{Int64}, Vector{Int64}, Vector{Float64}} where {_A<:AbstractVector{Int64}, _B<:AbstractVector{Int64}, _C<:AbstractVector{Int64}, _D<:AbstractVector{Int64}, _E<:AbstractVector{Int64}, _F<:FiniteElementContainers.NodalField, _G<:AbstractVector{Float64}, _H, _I, _J, _K}), L<:(LinearSolve.LinearCache{LinearAlgebra.Symmetric{Float64, SparseArrays.SparseMatrixCSC{Float64, Int64}}, _A, _B, SciMLBase.NullParameters, LinearSolve.DefaultLinearSolver, LinearSolve.DefaultLinearSolverInit{LinearAlgebra.LU{Float64, SparseArrays.SparseMatrixCSC{Float64, Int64}, Vector{Int64}}, LinearAlgebra.QR{Float64, SparseArrays.SparseMatrixCSC{Float64, Int64}, Vector{Float64}}, Nothing, Nothing, Sparspak.SpkSparseSolver.SparseSolver{Int64, Float64}, Nothing, Nothing, _A1, LinearAlgebra.LU{Float64, SparseArrays.SparseMatrixCSC{Float64, Int64}, Vector{Int64}}, Tuple{LinearAlgebra.LU{Float64, SparseArrays.SparseMatrixCSC{Float64, Int64}, Vector{Int64}}, Vector{Int64}}, Nothing, Nothing, SparseArrays.CHOLMOD.Factor{Float64, Int64}, Nothing, SparseArrays.CHOLMOD.Factor{Float64, Int64}, SparseArrays.CHOLMOD.Factor{Float64, Int64}, Tuple{LinearAlgebra.LU{Float64, Matrix{Float64}, Vector{Int32}}, Base.RefValue{Int32}}, Tuple{LinearAlgebra.LU{Float64, Matrix{Float64}, Vector{Int64}}, Base.RefValue{Int64}}, LinearAlgebra.QRPivoted{Float64, SparseArrays.SparseMatrixCSC{Float64, Int64}, Vector{Float64}, Vector{Int64}}, _B1, _C}, SciMLOperators.IdentityOperator, SciMLOperators.IdentityOperator, _C1, Bool, LinearSolve.LinearSolveAdjoint{Missing}} where {_A, _B, _A1, _B1, _C, _C1})}\n\n\nDirect linear solver constructor from a Domain\n\n\n\n\n\n","category":"method"},{"location":"linear_solvers/#Cthonios.DirectSolver-Tuple{Objective, Any, Any}","page":"Linear solvers","title":"Cthonios.DirectSolver","text":"DirectSolver(\n    obj::Objective,\n    p,\n    timer\n) -> DirectSolver{A, L} where {A<:(FiniteElementContainers.StaticAssembler{Float64, Int64, _A, _B, _C, _D, _E, _F, _G, _H, _I, _J, _K, Vector{Int64}, Vector{Int64}, Vector{Float64}} where {_A<:AbstractVector{Int64}, _B<:AbstractVector{Int64}, _C<:AbstractVector{Int64}, _D<:AbstractVector{Int64}, _E<:AbstractVector{Int64}, _F<:FiniteElementContainers.NodalField, _G<:AbstractVector{Float64}, _H, _I, _J, _K}), L<:(LinearSolve.LinearCache{LinearAlgebra.Symmetric{Float64, SparseArrays.SparseMatrixCSC{Float64, Int64}}, _A, _B, SciMLBase.NullParameters, LinearSolve.DefaultLinearSolver, LinearSolve.DefaultLinearSolverInit{LinearAlgebra.LU{Float64, SparseArrays.SparseMatrixCSC{Float64, Int64}, Vector{Int64}}, LinearAlgebra.QR{Float64, SparseArrays.SparseMatrixCSC{Float64, Int64}, Vector{Float64}}, Nothing, Nothing, Sparspak.SpkSparseSolver.SparseSolver{Int64, Float64}, Nothing, Nothing, _A1, LinearAlgebra.LU{Float64, SparseArrays.SparseMatrixCSC{Float64, Int64}, Vector{Int64}}, Tuple{LinearAlgebra.LU{Float64, SparseArrays.SparseMatrixCSC{Float64, Int64}, Vector{Int64}}, Vector{Int64}}, Nothing, Nothing, SparseArrays.CHOLMOD.Factor{Float64, Int64}, Nothing, SparseArrays.CHOLMOD.Factor{Float64, Int64}, SparseArrays.CHOLMOD.Factor{Float64, Int64}, Tuple{LinearAlgebra.LU{Float64, Matrix{Float64}, Vector{Int32}}, Base.RefValue{Int32}}, Tuple{LinearAlgebra.LU{Float64, Matrix{Float64}, Vector{Int64}}, Base.RefValue{Int64}}, LinearAlgebra.QRPivoted{Float64, SparseArrays.SparseMatrixCSC{Float64, Int64}, Vector{Float64}, Vector{Int64}}, _B1, _C}, SciMLOperators.IdentityOperator, SciMLOperators.IdentityOperator, _C1, Bool, LinearSolve.LinearSolveAdjoint{Missing}} where {_A, _B, _A1, _B1, _C, _C1})}\n\n\nDirect linear solver constructor from a Domain\n\n\n\n\n\n","category":"method"},{"location":"linear_solvers/#Cthonios.gradient!-Tuple{DirectSolver, Objective, Any, ObjectiveParameters}","page":"Linear solvers","title":"Cthonios.gradient!","text":"gradient!(\n    solver::DirectSolver,\n    obj::Objective,\n    Uu,\n    p::ObjectiveParameters\n)\n\n\n\n\n\n\n","category":"method"},{"location":"linear_solvers/#Cthonios.hessian!-Tuple{DirectSolver, Any, Any, Any}","page":"Linear solvers","title":"Cthonios.hessian!","text":"hessian!(solver::DirectSolver, obj, Uu, p)\n\n\n\n\n\n\n","category":"method"},{"location":"linear_solvers/#Cthonios.residual_norm-Tuple{DirectSolver, Any, Any, Any}","page":"Linear solvers","title":"Cthonios.residual_norm","text":"residual_norm(solver::DirectSolver, obj, Uu, p) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"linear_solvers/#Cthonios.solve!-Tuple{Any, DirectSolver, Any, Any, Any}","page":"Linear solvers","title":"Cthonios.solve!","text":"solve!(ΔUu, solver::DirectSolver, obj, Uu, p)\n\n\n\n\n\n\n","category":"method"},{"location":"linear_solvers/#Preconditioners","page":"Linear solvers","title":"Preconditioners","text":"","category":"section"},{"location":"linear_solvers/","page":"Linear solvers","title":"Linear solvers","text":"Modules = [Cthonios]\nPages = [\"solvers/linear_solvers/Preconditioners.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"linear_solvers/#Cthonios.AbstractPreconditioner","page":"Linear solvers","title":"Cthonios.AbstractPreconditioner","text":"abstract type AbstractPreconditioner\n\nAbstract base preconditioner type.\n\n\n\n\n\n","category":"type"},{"location":"linear_solvers/#Cthonios.CholeskyPreconditioner","page":"Linear solvers","title":"Cthonios.CholeskyPreconditioner","text":"mutable struct CholeskyPreconditioner{A, P, T} <: Cthonios.AbstractPreconditioner\n\nassembler::Any\npreconditioner::Any\ntimer::Any\n\n\n\n\n\n","category":"type"},{"location":"linear_solvers/#Cthonios.CholeskyPreconditioner-Tuple{Objective, Any, Any}","page":"Linear solvers","title":"Cthonios.CholeskyPreconditioner","text":"CholeskyPreconditioner(\n    obj::Objective,\n    p,\n    timer\n) -> CholeskyPreconditioner{A, SparseArrays.CHOLMOD.Factor{Float64, Int64}} where A<:(FiniteElementContainers.StaticAssembler{Float64, Int64, _A, _B, _C, _D, _E, _F, _G, _H, _I, _J, _K, Vector{Int64}, Vector{Int64}, Vector{Float64}} where {_A<:AbstractVector{Int64}, _B<:AbstractVector{Int64}, _C<:AbstractVector{Int64}, _D<:AbstractVector{Int64}, _E<:AbstractVector{Int64}, _F<:FiniteElementContainers.NodalField, _G<:AbstractVector{Float64}, _H, _I, _J, _K})\n\n\n\n\n\n\n","category":"method"},{"location":"linear_solvers/#Cthonios.LDLPreconditioner","page":"Linear solvers","title":"Cthonios.LDLPreconditioner","text":"struct LDLPreconditioner{A, P, T} <: Cthonios.AbstractPreconditioner\n\nassembler::Any\npreconditioner::Any\ntimer::Any\n\n\n\n\n\n","category":"type"},{"location":"linear_solvers/#Cthonios.LDLPreconditioner-Tuple{Objective, Any, Any}","page":"Linear solvers","title":"Cthonios.LDLPreconditioner","text":"LDLPreconditioner(\n    obj::Objective,\n    p,\n    timer\n) -> LDLPreconditioner{A, LDLFactorizations.LDLFactorization{Float64, Int64, Int64, Int64}} where A<:(FiniteElementContainers.StaticAssembler{Float64, Int64, _A, _B, _C, _D, _E, _F, _G, _H, _I, _J, _K, Vector{Int64}, Vector{Int64}, Vector{Float64}} where {_A<:AbstractVector{Int64}, _B<:AbstractVector{Int64}, _C<:AbstractVector{Int64}, _D<:AbstractVector{Int64}, _E<:AbstractVector{Int64}, _F<:FiniteElementContainers.NodalField, _G<:AbstractVector{Float64}, _H, _I, _J, _K})\n\n\n\n\n\n\n","category":"method"},{"location":"linear_solvers/#Cthonios.LimitedLDLPreconditioner","page":"Linear solvers","title":"Cthonios.LimitedLDLPreconditioner","text":"mutable struct LimitedLDLPreconditioner{A, P, T} <: Cthonios.AbstractPreconditioner\n\nassembler::Any\npreconditioner::Any\ntimer::Any\n\n\n\n\n\n","category":"type"},{"location":"linear_solvers/#Cthonios.LimitedLDLPreconditioner-Tuple{Objective, Any, Any}","page":"Linear solvers","title":"Cthonios.LimitedLDLPreconditioner","text":"LimitedLDLPreconditioner(\n    obj::Objective,\n    p,\n    timer\n) -> LimitedLDLPreconditioner{A, LimitedLDLFactorizations.LimitedLDLFactorization{Float64, Int64, Vector{Int64}, Vector{Int64}}} where A<:(FiniteElementContainers.StaticAssembler{Float64, Int64, _A, _B, _C, _D, _E, _F, _G, _H, _I, _J, _K, Vector{Int64}, Vector{Int64}, Vector{Float64}} where {_A<:AbstractVector{Int64}, _B<:AbstractVector{Int64}, _C<:AbstractVector{Int64}, _D<:AbstractVector{Int64}, _E<:AbstractVector{Int64}, _F<:FiniteElementContainers.NodalField, _G<:AbstractVector{Float64}, _H, _I, _J, _K})\n\n\n\n\n\n\n","category":"method"},{"location":"linear_solvers/#LinearAlgebra.ldiv!-Tuple{Any, CholeskyPreconditioner, Any}","page":"Linear solvers","title":"LinearAlgebra.ldiv!","text":"ldiv!(y, P::CholeskyPreconditioner, v)\n\n\n\n\n\n\n","category":"method"},{"location":"nonlinear_solvers/","page":"Nonlinear solvers","title":"Nonlinear solvers","text":"CurrentModule = Cthonios","category":"page"},{"location":"nonlinear_solvers/#Nonlinear-Solvers","page":"Nonlinear solvers","title":"Nonlinear Solvers","text":"","category":"section"},{"location":"nonlinear_solvers/","page":"Nonlinear solvers","title":"Nonlinear solvers","text":"One of our goals is to make adding new and hacking existing nonlinear solvers easy!","category":"page"},{"location":"nonlinear_solvers/#Input-File-Syntax-Example","page":"Nonlinear solvers","title":"Input File Syntax Example","text":"","category":"section"},{"location":"nonlinear_solvers/","page":"Nonlinear solvers","title":"Nonlinear solvers","text":"Below is an example input file block for a trust region solver that leverages a direct solver with an LDLT factorization. The nonlinear solver is also utilizing warm start to improve the first few iterations of each load step.","category":"page"},{"location":"nonlinear_solvers/","page":"Nonlinear solvers","title":"Nonlinear solvers","text":"linear solvers:\n  direct:\n    type: DirectLinearSolver\n    factorization method: ldl\n\nnonlinear solvers:\n  trs:\n    type: TrustRegionSolver\n    linear solver: direct\n    warm start: on","category":"page"},{"location":"nonlinear_solvers/#General-methods-and-abstract-types","page":"Nonlinear solvers","title":"General methods and abstract types","text":"","category":"section"},{"location":"nonlinear_solvers/","page":"Nonlinear solvers","title":"Nonlinear solvers","text":"Modules = [Cthonios]\nPages = [\"solvers/nonlinear_solvers/NonlinearSolvers.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"nonlinear_solvers/#Cthonios.AbstractNonlinearSolver","page":"Nonlinear solvers","title":"Cthonios.AbstractNonlinearSolver","text":"abstract type AbstractNonlinearSolver{L, O, U, T} <: Cthonios.AbstractSolver\n\na nonlinear solver needs to define the following methods\n\ncheck_convergence - returns a bool \nlogger - @info information\nstep! - step for the solver\n\nit needs the following types\n\na linear solver\nan objective\nan unknown vector\nan int called max_iter\n\n\n\n\n\n","category":"type"},{"location":"nonlinear_solvers/#Cthonios.solve!-Tuple{Cthonios.AbstractNonlinearSolver, Any, Any}","page":"Nonlinear solvers","title":"Cthonios.solve!","text":"solve!(solver::Cthonios.AbstractNonlinearSolver, Uu, p)\n\n\nGeneric method to fall back on if step! is defined\n\n\n\n\n\n","category":"method"},{"location":"nonlinear_solvers/#Newton-Solver","page":"Nonlinear solvers","title":"Newton Solver","text":"","category":"section"},{"location":"nonlinear_solvers/","page":"Nonlinear solvers","title":"Nonlinear solvers","text":"Modules = [Cthonios]\nPages = [\"solvers/nonlinear_solvers/NewtonSolver.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"nonlinear_solvers/#Cthonios.NewtonSolver","page":"Nonlinear solvers","title":"Cthonios.NewtonSolver","text":"struct NewtonSolver{L, O, U, T} <: Cthonios.AbstractNonlinearSolver{L, O, U, T}\n\nlinear_solver::Any\nobjective::Any\nΔUu::Any\ntimer::Any\nmax_iter::Int64\nabs_tol::Float64\nrel_tol::Float64\nuse_warm_start::Bool\n\n\n\n\n\n","category":"type"},{"location":"nonlinear_solvers/#Cthonios.NewtonSolver-Tuple{Dict{Symbol, Any}, Objective, Any, Any}","page":"Nonlinear solvers","title":"Cthonios.NewtonSolver","text":"NewtonSolver(\n    inputs::Dict{Symbol, Any},\n    objective::Objective,\n    p,\n    timer\n) -> NewtonSolver{_A, O} where {_A, O<:Objective}\n\n\n\n\n\n\n","category":"method"},{"location":"nonlinear_solvers/#Cthonios.NewtonSolver-Tuple{Objective, Any, Any, Any}","page":"Nonlinear solvers","title":"Cthonios.NewtonSolver","text":"NewtonSolver(\n    objective::Objective,\n    p,\n    linear_solver_type,\n    timer\n) -> NewtonSolver{_A, O} where {_A, O<:Objective}\n\n\n\n\n\n\n","category":"method"},{"location":"nonlinear_solvers/#Cthonios.check_convergence-Tuple{NewtonSolver, Any, Any, Any}","page":"Nonlinear solvers","title":"Cthonios.check_convergence","text":"check_convergence(\n    solver::NewtonSolver,\n    Uu,\n    p,\n    R0_norm\n) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"nonlinear_solvers/#Cthonios.logger-Tuple{NewtonSolver, Any, Any, Int64, Any}","page":"Nonlinear solvers","title":"Cthonios.logger","text":"logger(solver::NewtonSolver, Uu, p, n::Int64, norm_R0)\n\n\n\n\n\n\n","category":"method"},{"location":"nonlinear_solvers/#Cthonios.step!-Tuple{NewtonSolver, Any, Any}","page":"Nonlinear solvers","title":"Cthonios.step!","text":"step!(solver::NewtonSolver, Uu, p)\n\n\n\n\n\n\n","category":"method"},{"location":"nonlinear_solvers/#Trust-Region-Solver","page":"Nonlinear solvers","title":"Trust Region Solver","text":"","category":"section"},{"location":"nonlinear_solvers/","page":"Nonlinear solvers","title":"Nonlinear solvers","text":"Modules = [Cthonios]\nPages = [\"solvers/nonlinear_solvers/TrustRegionSolver.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"nonlinear_solvers/#Cthonios.TrustRegionSolver","page":"Nonlinear solvers","title":"Cthonios.TrustRegionSolver","text":"struct TrustRegionSolver{L, O, U<:(AbstractVector), T<:TimerOutputs.TimerOutput, W, F<:FiniteElementContainers.NodalField, S<:Cthonios.TrustRegionSolverSettings} <: Cthonios.AbstractNonlinearSolver{L, O, U<:(AbstractVector), T<:TimerOutputs.TimerOutput}\n\npreconditioner::Any\nobjective::Any\nΔUu::AbstractVector\ntimer::TimerOutputs.TimerOutput\nwarm_start::Any\no::AbstractVector\ng::FiniteElementContainers.NodalField\nHv::FiniteElementContainers.NodalField\ncauchy_point::AbstractVector\nq_newton_point::AbstractVector\nd::AbstractVector\ny_scratch_1::AbstractVector\ny_scratch_2::AbstractVector\ny_scratch_3::AbstractVector\ny_scratch_4::AbstractVector\nuse_warm_start::Bool\nsettings::Cthonios.TrustRegionSolverSettings\n\n\n\n\n\n","category":"type"},{"location":"nonlinear_solvers/#Cthonios.TrustRegionSolver-Tuple{Objective, Any, Any}","page":"Nonlinear solvers","title":"Cthonios.TrustRegionSolver","text":"TrustRegionSolver(\n    objective::Objective,\n    p,\n    timer;\n    preconditioner,\n    use_warm_start\n) -> TrustRegionSolver{L, O, Vector{Float64}, TimerOutputs.TimerOutput, W, F, Cthonios.TrustRegionSolverSettings} where {L<:(CholeskyPreconditioner{A, SparseArrays.CHOLMOD.Factor{Float64, Int64}} where A<:(FiniteElementContainers.StaticAssembler{Float64, Int64, _A, _B, _C, _D, _E, _F, _G, _H, _I, _J, _K, Vector{Int64}, Vector{Int64}, Vector{Float64}} where {_A<:AbstractVector{Int64}, _B<:AbstractVector{Int64}, _C<:AbstractVector{Int64}, _D<:AbstractVector{Int64}, _E<:AbstractVector{Int64}, _F<:FiniteElementContainers.NodalField, _G<:AbstractVector{Float64}, _H, _I, _J, _K})), O<:Objective, W<:Cthonios.WarmStart, F<:FiniteElementContainers.NodalField}\n\n\nTODO figure out which scratch arrays can be nixed\n\n\n\n\n\n","category":"method"},{"location":"nonlinear_solvers/#Cthonios.TrustRegionSolverSettings","page":"Nonlinear solvers","title":"Cthonios.TrustRegionSolverSettings","text":"t_1::Float64\nt_2::Float64\nη_1::Float64\nη_2::Float64\nη_3::Float64\nmax_trust_iters::Int64\ntol::Float64\nmax_cg_iters::Int64\nmax_cumulative_cg_iters::Int64\ncg_tol::Float64\ncg_inexact_solve_ratio::Float64\ntr_size::Float64\nmin_tr_size::Float64\ncheck_stability::Bool\nuse_preconditioned_inner_product_for_cg::Bool\nuse_incremental_objective::Bool\ndebug_info::Bool\nover_iter::Int64\n\n\n\n\n\n","category":"type"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"CurrentModule = Cthonios","category":"page"},{"location":"iterators/#Iterators","page":"Iterators","title":"Iterators","text":"","category":"section"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"Modules = [Cthonios]\nPages = [\"Iterators.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"iterators/#Cthonios.domain_iterator!-Tuple{Any, Any, Domain, Any, ObjectiveParameters}","page":"Iterators","title":"Cthonios.domain_iterator!","text":"domain_iterator!(\n    global_val,\n    f,\n    domain::Domain,\n    Uu,\n    p::ObjectiveParameters\n)\n\n\nIterator over a domain domain to fill a global value global_val based on a quadrature level function  f provided a nodal field U and set of paramaters p. This method is useful for filling quantities such as objectives, gradients, or hessians.\n\n\n\n\n\n","category":"method"},{"location":"iterators/#Cthonios.element_coordinates-Tuple{Any, Any, Any}","page":"Iterators","title":"Cthonios.element_coordinates","text":"element_coordinates(section, X, e) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"iterators/#Cthonios.element_fields-Tuple{Any, Any, Any}","page":"Iterators","title":"Cthonios.element_fields","text":"element_fields(section, U, e) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"iterators/#Cthonios.scratch_variable-Tuple{FiniteElementContainers.Assembler, Any}","page":"Iterators","title":"Cthonios.scratch_variable","text":"scratch_variable(\n    global_val::FiniteElementContainers.Assembler,\n    section\n) -> Any\n\n\nSetup a scratch variable for a stiffness like calculation\n\n\n\n\n\n","category":"method"},{"location":"iterators/#Cthonios.scratch_variable-Tuple{Vector, Any}","page":"Iterators","title":"Cthonios.scratch_variable","text":"scratch_variable(global_val::Vector, section) -> Any\n\n\nSetup a scratch variable for an energy like calculation\n\n\n\n\n\n","category":"method"},{"location":"iterators/#Cthonios.scratch_variable-Union{Tuple{T}, Tuple{T, Any}} where T<:Union{FiniteElementContainers.NodalField, Matrix}","page":"Iterators","title":"Cthonios.scratch_variable","text":"scratch_variable(\n    global_val::Union{FiniteElementContainers.NodalField, Matrix},\n    section\n) -> Any\n\n\nSetup a scratch variable for a force like calculation\n\n\n\n\n\n","category":"method"},{"location":"objectives/","page":"Objectives","title":"Objectives","text":"CurrentModule = Cthonios","category":"page"},{"location":"objectives/#Objectives","page":"Objectives","title":"Objectives","text":"","category":"section"},{"location":"objectives/","page":"Objectives","title":"Objectives","text":"Modules = [Cthonios]\nPages = [\"Objectives.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"objectives/#Cthonios.AbstractObjective","page":"Objectives","title":"Cthonios.AbstractObjective","text":"abstract type AbstractObjective\n\nAbstract base objective type.\n\n\n\n\n\n","category":"type"},{"location":"objectives/#Cthonios.AbstractObjectiveParameters","page":"Objectives","title":"Cthonios.AbstractObjectiveParameters","text":"abstract type AbstractObjectiveParameters\n\nAbstract base type for objective function parameters.\n\n\n\n\n\n","category":"type"},{"location":"objectives/#Cthonios.Objective","page":"Objectives","title":"Cthonios.Objective","text":"struct Objective{D, F1, F2, F3, F4, F5, F6, T}\n\ndomain::Any\nvalue::Any\ngradient::Any\nhessian::Any\nneumann_value::Any\nneumann_gradient::Any\nneumann_hessian::Any\ntimer::Any\n\nObjective type for evaluating objective functions. The functions correspond to quadrature level evaluations of the objective function, it's gradient, and it's hessian respectively. domain - A domain object  value - A function for the quadrature level objective function evaluation. gradient - A function for the quadrature level objective function gradient evaluation. hessian - A function for the quadrature level objective hessian evaluation. timer - A timer that's already setup.\n\n\n\n\n\n","category":"type"},{"location":"objectives/#Cthonios.ObjectiveParameters","page":"Objectives","title":"Cthonios.ObjectiveParameters","text":"struct ObjectiveParameters{U1, T, B, N, S, P, U2, U3, Q} <: Cthonios.AbstractObjectiveParameters\n\nX::Any\nt::Any\nUbc::Any\nnbc::Any\nstate_old::Any\nstate_new::Any\nprops::Any\nU::Any\nhvp_scratch::Any\nq_vals_scratch::Any\n\nType for objective function parameters for design parameters such as coordinates, time, bc values, properties state variables, and some scratch arrays.\n\n\n\n\n\n","category":"type"},{"location":"objectives/#Cthonios.ObjectiveParameters-Tuple{Objective, Any}","page":"Objectives","title":"Cthonios.ObjectiveParameters","text":"ObjectiveParameters(\n    o::Objective,\n    times\n) -> ObjectiveParameters{_A, _B, B, N} where {_A, _B, B<:(Vector), N<:(Vector{T} where T<:(StaticArraysCore.SVector{_A, _B} where {_B, _A}))}\n\n\nConstructor for a ObjectiveParameters type. o - Objective function object. times - Times object.\n\n\n\n\n\n","category":"method"},{"location":"objectives/#Cthonios.gradient!-Tuple{Any, Objective, Any, ObjectiveParameters}","page":"Objectives","title":"Cthonios.gradient!","text":"gradient!(g, o::Objective, Uu, p::ObjectiveParameters)\n\n\n\n\n\n\n","category":"method"},{"location":"objectives/#Cthonios.hessian!-Tuple{FiniteElementContainers.Assembler, Objective, Any, ObjectiveParameters}","page":"Objectives","title":"Cthonios.hessian!","text":"hessian!(\n    asm::FiniteElementContainers.Assembler,\n    o::Objective,\n    Uu,\n    p::ObjectiveParameters\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"objectives/#Cthonios.hvp!-Tuple{AbstractVector, Objective, Any, ObjectiveParameters, Any}","page":"Objectives","title":"Cthonios.hvp!","text":"hvp!(\n    Hv::AbstractVector,\n    o::Objective,\n    Uu,\n    p::ObjectiveParameters,\n    Vv\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"objectives/#Cthonios.hvp!-Tuple{FiniteElementContainers.NodalField, Objective, Any, ObjectiveParameters, Any}","page":"Objectives","title":"Cthonios.hvp!","text":"hvp!(\n    Hv::FiniteElementContainers.NodalField,\n    o::Objective,\n    Uu,\n    p::ObjectiveParameters,\n    Vv\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"objectives/#Cthonios.objective!-Tuple{Any, Objective, Any, ObjectiveParameters}","page":"Objectives","title":"Cthonios.objective!","text":"objective!(\n    val,\n    o::Objective,\n    Uu,\n    p::ObjectiveParameters\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"objectives/#Cthonios.step!-Tuple{ObjectiveParameters}","page":"Objectives","title":"Cthonios.step!","text":"step!(p::ObjectiveParameters)\n\n\n\n\n\n\n","category":"method"},{"location":"objectives/#Cthonios.update_dirichlet_vals!-Tuple{ObjectiveParameters, Objective}","page":"Objectives","title":"Cthonios.update_dirichlet_vals!","text":"update_dirichlet_vals!(p::ObjectiveParameters, o::Objective)\n\n\n\n\n\n\n","category":"method"},{"location":"objectives/#Cthonios.update_neumann_vals!-Tuple{ObjectiveParameters, Objective}","page":"Objectives","title":"Cthonios.update_neumann_vals!","text":"update_neumann_vals!(p::ObjectiveParameters, o::Objective)\n\n\n\n\n\n\n","category":"method"},{"location":"bcs/#Boundary-Conditions","page":"Boundary Conditions","title":"Boundary Conditions","text":"","category":"section"},{"location":"bcs/","page":"Boundary Conditions","title":"Boundary Conditions","text":"Modules = [Cthonios]\nPages = [\"BoundaryConditions.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"physics/#Physics","page":"Physics","title":"Physics","text":"","category":"section"},{"location":"physics/#General-methods-and-abstract-types","page":"Physics","title":"General methods and abstract types","text":"","category":"section"},{"location":"physics/","page":"Physics","title":"Physics","text":"Modules = [Cthonios]\nPages = [\"physics/Physics.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"physics/#Cthonios.AbstractPhysics","page":"Physics","title":"Cthonios.AbstractPhysics","text":"abstract type AbstractPhysics{NF, NP, NS}\n\nNF - Number of fields in this physics\n\nNP - Number of properties in this physics\n\nNS - Number of states in this physics\n\n\n\n\n\n","category":"type"},{"location":"physics/#Cthonios.num_fields-Union{Tuple{Cthonios.AbstractPhysics{NF, NP, NS}}, Tuple{NS}, Tuple{NP}, Tuple{NF}} where {NF, NP, NS}","page":"Physics","title":"Cthonios.num_fields","text":"num_fields(_::Cthonios.AbstractPhysics{NF, NP, NS}) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"physics/#Cthonios.num_properties-Union{Tuple{Cthonios.AbstractPhysics{NF, NP, NS}}, Tuple{NS}, Tuple{NP}, Tuple{NF}} where {NF, NP, NS}","page":"Physics","title":"Cthonios.num_properties","text":"num_properties(\n    _::Cthonios.AbstractPhysics{NF, NP, NS}\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"physics/#Cthonios.num_states-Union{Tuple{Cthonios.AbstractPhysics{NF, NP, NS}}, Tuple{NS}, Tuple{NP}, Tuple{NF}} where {NF, NP, NS}","page":"Physics","title":"Cthonios.num_states","text":"num_states(_::Cthonios.AbstractPhysics{NF, NP, NS}) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"physics/#Cthonios.reshape_field-Tuple{Cthonios.AbstractPhysics, Any, Any}","page":"Physics","title":"Cthonios.reshape_field","text":"comes in as (Nnodes x nfields) vector returns as nfields x nnodes matrix\n\n\n\n\n\n","category":"method"},{"location":"physics/#Lagrangian-Solid-Mechanics","page":"Physics","title":"Lagrangian Solid Mechanics","text":"","category":"section"},{"location":"physics/","page":"Physics","title":"Physics","text":"Modules = [Cthonios]\nPages = [\"physics/SolidMechanics.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"physics/#Cthonios.SolidMechanics","page":"Physics","title":"Cthonios.SolidMechanics","text":"struct SolidMechanics{NF, NP, NS, Mat, Form, P<:Cthonios.StressDivergence{NF, NP, NS, Mat, Form}} <: Cthonios.AbstractPhysics{NF, NP, NS}\n\nmaterial_model::Any\nformulation::Any\nstress_divergence::Cthonios.StressDivergence{NF, NP, NS, Mat, Form} where {NF, NP, NS, Mat, Form}\n\n\n\n\n\n","category":"type"},{"location":"physics/#Cthonios.energy-Union{Tuple{T}, Tuple{SolidMechanics, T, Vararg{Any, 5}}} where T<:AbstractArray","page":"Physics","title":"Cthonios.energy","text":"energy(\n    physics::SolidMechanics,\n    u::AbstractArray,\n    ∇u,\n    X,\n    t,\n    Z,\n    props\n) -> Any\n\n\nEnergy method at the quadrature level for Lagrangian solid mechanics. This equivalent to the quadrature point calculation needed for the  following integral Pi = int_Omegapsileft(mathbfFright)dOmega\n\n\n\n\n\n","category":"method"},{"location":"physics/#Cthonios.gradient-Tuple{SolidMechanics, Vararg{Any, 8}}","page":"Physics","title":"Cthonios.gradient","text":"gradient(\n    physics::SolidMechanics,\n    u,\n    ∇u,\n    v,\n    ∇v,\n    X,\n    t,\n    Z,\n    props\n) -> Any\n\n\nGradient method at the quadrature level for Lagrangian solid mechanics. This equivalent to the quadrature point calculation needed for the  following integral mathbff = int_OmegamathbfPdeltamathbfFdOmega\n\n\n\n\n\n","category":"method"},{"location":"physics/#Cthonios.hessian-Tuple{SolidMechanics, Vararg{Any, 8}}","page":"Physics","title":"Cthonios.hessian","text":"hessian(\n    physics::SolidMechanics,\n    u,\n    ∇u,\n    v,\n    ∇v,\n    X,\n    t,\n    Z,\n    props\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"physics/#Poisson","page":"Physics","title":"Poisson","text":"","category":"section"},{"location":"physics/","page":"Physics","title":"Physics","text":"Modules = [Cthonios]\nPages = [\"physics/Poisson.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"physics/#Cthonios.Poisson","page":"Physics","title":"Cthonios.Poisson","text":"struct Poisson{Form, S} <: Cthonios.AbstractPhysics{1, 0, 0}\n\nformulation::Any\nlaplacian::Cthonios.Laplacian{1}\nsource::Any\n\nTODO create source term kernel\n\n\n\n\n\n","category":"type"},{"location":"physics/#Cthonios.energy-Union{Tuple{T}, Tuple{Poisson, T, Vararg{Any, 5}}} where T<:AbstractArray","page":"Physics","title":"Cthonios.energy","text":"energy(\n    physics::Poisson,\n    u::AbstractArray,\n    ∇u,\n    X,\n    t,\n    Z,\n    props\n) -> Any\n\n\nEnergy method for Poisson equation at a quadrature point Pilefturight = int_Omega leftfrac12nabla u^2 - furightdOmega\n\n\n\n\n\n","category":"method"},{"location":"physics/#Cthonios.gradient-Tuple{Poisson, Vararg{Any, 8}}","page":"Physics","title":"Cthonios.gradient","text":"gradient(\n    physics::Poisson,\n    u,\n    ∇u,\n    v,\n    ∇v,\n    X,\n    t,\n    Z,\n    props\n) -> Any\n\n\nGradient method for Poisson equation at a quadrature point gleft(u vright) = int_Omega leftnabla ucdotnabla v - fvrightdOmega\n\n\n\n\n\n","category":"method"},{"location":"physics/#Cthonios.hessian-Tuple{Poisson, Vararg{Any, 8}}","page":"Physics","title":"Cthonios.hessian","text":"hessian(\n    physics::Poisson,\n    u,\n    ∇u,\n    v,\n    ∇v,\n    X,\n    t,\n    Z,\n    props\n) -> Any\n\n\nHessian method for Poisson equation at a quadrature point Hleft(u vright) = int_Omega leftnabla vcdotnabla vrightdOmega\n\n\n\n\n\n","category":"method"},{"location":"running_cthonios/","page":"Running Cthonios","title":"Running Cthonios","text":"CurrentModule = Cthonios","category":"page"},{"location":"running_cthonios/#Running-from-the-REPL","page":"Running Cthonios","title":"Running from the REPL","text":"","category":"section"},{"location":"running_cthonios/","page":"Running Cthonios","title":"Running Cthonios","text":"To run Cthonios from the REPL one can utilize the following method","category":"page"},{"location":"running_cthonios/","page":"Running Cthonios","title":"Running Cthonios","text":"TODO","category":"page"},{"location":"running_cthonios/#Running-Cthonios-as-an-executable","page":"Running Cthonios","title":"Running Cthonios as an executable","text":"","category":"section"},{"location":"running_cthonios/","page":"Running Cthonios","title":"Running Cthonios","text":"To run Cthonios as an executable, one must first run the CthoniosBuild.jl script (assuming one has PackageCompiler installed already). This will build an executable called cthonios in a build folder. To run Cthonios you can use the following command","category":"page"},{"location":"running_cthonios/","page":"Running Cthonios","title":"Running Cthonios","text":"/path/to/cthonios -i <input-file.yaml>","category":"page"},{"location":"running_cthonios/#Complete-example-input-file","page":"Running Cthonios","title":"Complete example input file","text":"","category":"section"},{"location":"running_cthonios/","page":"Running Cthonios","title":"Running Cthonios","text":"# Global scope\nfunctions:\n  displacement_ramp: \n    type: ScalarFunction{2, Float64, Float64, Float64}\n    expression: (x, t) -> -0.5 * t\n  zero_func:\n    type: ScalarFunction{2, Float64, Float64, Float64}\n    expression: (x, t) -> 0.0\n\nmaterials:\n  soft rubber:\n    model: NeoHookean\n    properties:\n      bulk modulus: 50.0\n      shear modulus: 1.0\n\nlinear solvers:\n  direct:\n    type: DirectLinearSolver\n    factorization method: ldl\n\nnonlinear solvers:\n  trs:\n    type: TrustRegionSolver\n    linear solver: direct\n    warm start: on\n\n# Domains scope\ndomains:\n  domain_1:\n    mesh:\n      type: ExodusDatabase{Int32, Int32, Int32, Float64}\n      file name: window_pain_tri3.g\n\n    boundary conditions:\n      displacement: \n      - nodeset ids: [3]\n        dofs: [1, 2]\n        function: zero_func\n      - nodeset ids: [1]\n        dofs: [1]\n        function: zero_func\n      - nodeset ids: [1]\n        dofs: [2]\n        function: displacement_ramp\n\n    sections:\n    - type: TotalLagrangeSection\n      block id: 1\n      formulation: plane strain\n      material: soft rubber\n\n    time stepper:\n      type: ConstantTimeStepper\n      start time: 0.0\n      end time: 1.0\n      time step: 0.025\n\nproblems:\n  - type: ForwardProblem\n    domain: domain_1\n    solver: trs\n    results:\n      output file name: output.e\n      nodal fields:\n      - displacement\n      - internal force\n      element fields:\n      - properties\n      quadrature fields:\n      - state variables\n\n  - type: EnergySensitivityProblem\n    domain: domain_1\n    solver: trs\n    results:\n      output file name: gradients.e\n      nodal fields:\n      - displacement\n      - dcoordinates\n      element fields:\n      - dproperties","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = Cthonios","category":"page"},{"location":"#Cthonios","page":"Home","title":"Cthonios","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for Cthonios.","category":"page"},{"location":"time_steppers/","page":"TimeSteppers","title":"TimeSteppers","text":"CurrentModule = Cthonios","category":"page"},{"location":"time_steppers/#Time-steppers","page":"TimeSteppers","title":"Time steppers","text":"","category":"section"},{"location":"time_steppers/","page":"TimeSteppers","title":"TimeSteppers","text":"Modules = [Cthonios]\nPages = [\"TimeSteppers.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"time_steppers/#Cthonios.AbstractTimeStepper","page":"TimeSteppers","title":"Cthonios.AbstractTimeStepper","text":"abstract type AbstractTimeStepper{T}\n\nAbstract type for time steppers.  Expects a type T to correspond to the type for time values such as Float64 or a time with a unit from for example Unitful.\n\n\n\n\n\n","category":"type"},{"location":"time_steppers/#Cthonios.ConstantTimeStepper","page":"TimeSteppers","title":"Cthonios.ConstantTimeStepper","text":"struct ConstantTimeStepper{T, S<:AbstractArray{T, 1}, I<:(AbstractVector{<:Integer})} <: Cthonios.AbstractTimeStepper{T}\n\nstart_time::Any\nend_time::Any\ncurrent_time::AbstractVector\ncurrent_time_step::AbstractVector{<:Integer}\nΔt::AbstractVector\n\nTime stepper type with a constant time step. start_time - the initial time value. end_time - time to end the simulation. current_time - the current time stored by this time stepper. current_time_step - the current index of the time step. Δt - the time step to use for all time steps.\n\n\n\n\n\n","category":"type"},{"location":"time_steppers/#Cthonios.ConstantTimeStepper-Union{Tuple{T}, Tuple{T, T, T}} where T<:Number","page":"TimeSteppers","title":"Cthonios.ConstantTimeStepper","text":"ConstantTimeStepper(\n    start_time::Number,\n    end_time::Number,\n    Δt::Number\n) -> ConstantTimeStepper\n\n\nMethod to construct a ConstantTimeStepper. start_time - the initial time value. end_time - time to end the simulation. Δt - the time step to use for all time steps.\n\n\n\n\n\n","category":"method"},{"location":"time_steppers/#Cthonios.step!-Tuple{ConstantTimeStepper}","page":"TimeSteppers","title":"Cthonios.step!","text":"step!(time::ConstantTimeStepper)\n\n\nMethod to increment time.current_time by Δt.\n\n\n\n\n\n","category":"method"}]
}
