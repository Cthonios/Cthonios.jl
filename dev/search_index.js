var documenterSearchIndex = {"docs":
[{"location":"materials/","page":"Materials","title":"Materials","text":"CurrentModule = Cthonios","category":"page"},{"location":"materials/#Materials","page":"Materials","title":"Materials","text":"","category":"section"},{"location":"materials/","page":"Materials","title":"Materials","text":"Cthonios utilizes ConstitutiveModels.jl as a material model backend.","category":"page"},{"location":"generated/hole_array/","page":"Hole Array","title":"Hole Array","text":"EditURL = \"../../../examples/hole_array/script.jl\"","category":"page"},{"location":"generated/hole_array/#Load-up-necessary-packages","page":"Hole Array","title":"Load up necessary packages","text":"","category":"section"},{"location":"generated/hole_array/","page":"Hole Array","title":"Hole Array","text":"using Cthonios","category":"page"},{"location":"generated/hole_array/","page":"Hole Array","title":"Hole Array","text":"using Meshes","category":"page"},{"location":"generated/hole_array/","page":"Hole Array","title":"Hole Array","text":"import Meshes: SimpleMesh, viz","category":"page"},{"location":"generated/hole_array/#File-management","page":"Hole Array","title":"File management","text":"","category":"section"},{"location":"generated/hole_array/","page":"Hole Array","title":"Hole Array","text":"mesh_file = \"../../../examples/hole_array/hole_array.exo\"","category":"page"},{"location":"generated/hole_array/#Functions-for-BCs","page":"Hole Array","title":"Functions for BCs","text":"","category":"section"},{"location":"generated/hole_array/","page":"Hole Array","title":"Hole Array","text":"func_1(x, t) = -5. * t#(0., -5. * t)\nfunc_2(x, t) = 0.0\nfunc_3(x, t) = @SVector [0., -0.025 * t]","category":"page"},{"location":"generated/hole_array/#Boundary-conditions","page":"Hole Array","title":"Boundary conditions","text":"","category":"section"},{"location":"generated/hole_array/","page":"Hole Array","title":"Hole Array","text":"disp_bcs = [\n  DirichletBC(\"yminus_nodeset\", [1, 2], func_2)\n  DirichletBC(\"yplus_nodeset\", [1], func_2)\n  DirichletBC(\"yplus_nodeset\", [2], func_1)\n]\ntraction_bcs = [\n]","category":"page"},{"location":"generated/hole_array/#Sections","page":"Hole Array","title":"Sections","text":"","category":"section"},{"location":"generated/hole_array/","page":"Hole Array","title":"Hole Array","text":"sections = Section[\n  Section(\n    \"Block1\", 2,\n    SolidMechanics(NeoHookean(), PlaneStrain()),\n    MaterialProperties(\n      \"bulk modulus\" => 0.833,\n      \"shear modulus\" => 1.0\n    )\n  )\n]","category":"page"},{"location":"generated/hole_array/#Domain-setup","page":"Hole Array","title":"Domain setup","text":"","category":"section"},{"location":"generated/hole_array/","page":"Hole Array","title":"Hole Array","text":"domain = Domain(mesh_file, sections, disp_bcs, traction_bcs)","category":"page"},{"location":"generated/hole_array/#Objective-setup","page":"Hole Array","title":"Objective setup","text":"","category":"section"},{"location":"generated/hole_array/","page":"Hole Array","title":"Hole Array","text":"objective = Objective(domain, Cthonios.energy)","category":"page"},{"location":"generated/hole_array/#Integrator-setup","page":"Hole Array","title":"Integrator setup","text":"","category":"section"},{"location":"generated/hole_array/","page":"Hole Array","title":"Hole Array","text":"integrator = QuasiStatic(0.0, 1.0, 1. / 20)","category":"page"},{"location":"generated/hole_array/#Post-processor","page":"Hole Array","title":"Post-processor","text":"","category":"section"},{"location":"generated/hole_array/","page":"Hole Array","title":"Hole Array","text":"pp = ExodusPostProcessor(mesh_file, \"output.e\", [\"displ_x\", \"displ_y\"])\nproblem = Problem(objective, integrator, TrustRegionSolver, pp)","category":"page"},{"location":"generated/hole_array/#Finally,-solve-the-problem","page":"Hole Array","title":"Finally, solve the problem","text":"","category":"section"},{"location":"generated/hole_array/","page":"Hole Array","title":"Hole Array","text":"Uu, p = Cthonios.create_unknowns_and_parameters(problem)\nCthonios.solve!(problem, Uu, p)","category":"page"},{"location":"generated/hole_array/#Interactive-plotting","page":"Hole Array","title":"Interactive plotting","text":"","category":"section"},{"location":"generated/hole_array/","page":"Hole Array","title":"Hole Array","text":"exo = ExodusDatabase(\"output.e\", \"r\")\nmesh = SimpleMesh(exo, 20)\nviz(mesh)","category":"page"},{"location":"generated/hole_array/","page":"Hole Array","title":"Hole Array","text":"","category":"page"},{"location":"generated/hole_array/","page":"Hole Array","title":"Hole Array","text":"This page was generated using Literate.jl.","category":"page"},{"location":"sections/","page":"Sections","title":"Sections","text":"CurrentModule = Cthonios","category":"page"},{"location":"sections/#Sections","page":"Sections","title":"Sections","text":"","category":"section"},{"location":"sections/","page":"Sections","title":"Sections","text":"Within Cthonios, sections refer to groups or \"blocks\" of elements that share a common element topology and material model. We allow by default for each element to possess different fixed material properties and an arbitrary number of state variables. Since the material model is the same for all elements in a section, the number of state variables will be the same at each element/quadrature point.","category":"page"},{"location":"sections/#Input-file-syntax","page":"Sections","title":"Input file syntax","text":"","category":"section"},{"location":"sections/","page":"Sections","title":"Sections","text":"TODO","category":"page"},{"location":"sections/","page":"Sections","title":"Sections","text":"Modules = [Cthonios]\nPages = [\"Sections.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"sections/#Cthonios.AbstractSection","page":"Sections","title":"Cthonios.AbstractSection","text":"abstract type AbstractSection\n\nAbstract base type for sections (both for input and internal).\n\n\n\n\n\n","category":"type"},{"location":"sections/#Cthonios.AbstractSectionInput","page":"Sections","title":"Cthonios.AbstractSectionInput","text":"abstract type AbstractSectionInput <: Cthonios.AbstractSection\n\nAbstract type for section inputs.\n\n\n\n\n\n","category":"type"},{"location":"sections/#Cthonios.AbstractSectionInternal","page":"Sections","title":"Cthonios.AbstractSectionInternal","text":"abstract type AbstractSectionInternal{F, P} <: Cthonios.AbstractSection\n\nAbstract type for section internals. P corresponds to the physics F corresponds to the formulation\n\n\n\n\n\n","category":"type"},{"location":"sections/#Cthonios.Section","page":"Sections","title":"Cthonios.Section","text":"struct Section{P, M} <: Cthonios.AbstractSectionInput\n\nblock_name::String\nq_order::Int64\nphysics::Any\nprops::Any\n\nSection inputs. physics - Physics object to use in this section. block_name - Name of exodus block to construct section from. q_order - Quadrature Order to use\n\n\n\n\n\n","category":"type"},{"location":"sections/#Cthonios.SectionInternal","page":"Sections","title":"Cthonios.SectionInternal","text":"struct SectionInternal{F, P<:Cthonios.AbstractPhysics, M} <: Cthonios.AbstractSectionInternal{F, P<:Cthonios.AbstractPhysics}\n\nblock_id::Int64\nq_order::Int64\nfspace::Any\nphysics::Cthonios.AbstractPhysics\nprops::Any\n\nSection internals. physics - Physics object to use in this section. block_name - Name of exodus block to construct section from. fspace - Function space for this element type\n\n\n\n\n\n","category":"type"},{"location":"sections/#Cthonios.SectionInternal-Tuple{Any, DofManager, Any}","page":"Sections","title":"Cthonios.SectionInternal","text":"SectionInternal(\n    mesh,\n    dof::DofManager,\n    section\n) -> Cthonios.SectionInternal{F} where F<:(NonAllocatedFunctionSpace{_A, _B, FiniteElementContainers.VectorizedElementField{T, N, NN, NE, Vals}, _C, ReferenceFiniteElements.ReferenceFE{Itype, Ftype, Etype, SEType, Backend, EdgeNodes, FaceNodes, InteriorNodes, Coords, CellInterps, SurfaceCoords, SurfaceInterps}} where {_A, _B, T, N, NN, NE, Vals<:AbstractVector{T}, _C<:(ElementField), Itype, Ftype, Etype, SEType, Backend, EdgeNodes, FaceNodes, InteriorNodes, Coords, CellInterps, SurfaceCoords, SurfaceInterps})\n\n\nConstructor for SectionInternal. mesh - FileMesh object. dof - DofManager object. section - SectionInput object.\n\n\n\n\n\n","category":"method"},{"location":"sections/#Cthonios.SurfaceSectionInternal","page":"Sections","title":"Cthonios.SurfaceSectionInternal","text":"struct SurfaceSectionInternal{F, P<:Cthonios.AbstractPhysics, M, B} <: Cthonios.AbstractSectionInternal{F, P<:Cthonios.AbstractPhysics}\n\nblock_id::Int64\nq_order::Int64\nfspace::Any\nphysics::Cthonios.AbstractPhysics\nprops::Any\nbc::Any\n\nSection internals. physics - Physics object to use in this section. block_name - Name of exodus block to construct section from. fspace - Function space for this element type\n\n\n\n\n\n","category":"type"},{"location":"sections/#Base.size-Tuple{Cthonios.AbstractSectionInternal}","page":"Sections","title":"Base.size","text":"size(\n    section::Cthonios.AbstractSectionInternal\n) -> NTuple{4, Any}\n\n\nRetrieves the sizes of a section in the following tuple (ND, NN, NP, NS) where ND - Number of dimensions NN - Number of nodes per element NP - Number of properties NS - Number of states\n\n\n\n\n\n","category":"method"},{"location":"sections/#Cthonios.num_fields-Tuple{Cthonios.AbstractSection}","page":"Sections","title":"Cthonios.num_fields","text":"num_fields(section::Cthonios.AbstractSection) -> Any\n\n\nRetrieves the number of fields for the physics in section\n\n\n\n\n\n","category":"method"},{"location":"sections/#Cthonios.num_properties-Tuple{Cthonios.AbstractSection}","page":"Sections","title":"Cthonios.num_properties","text":"num_properties(section::Cthonios.AbstractSection) -> Any\n\n\nRetrieves the number of properties for the physics in section\n\n\n\n\n\n","category":"method"},{"location":"sections/#Cthonios.num_states-Tuple{Cthonios.AbstractSection}","page":"Sections","title":"Cthonios.num_states","text":"num_states(section::Cthonios.AbstractSection) -> Any\n\n\nRetrieves the number of states for the physics in section\n\n\n\n\n\n","category":"method"},{"location":"domains/","page":"Domains","title":"Domains","text":"CurrentModule = Cthonios","category":"page"},{"location":"domains/#Domains","page":"Domains","title":"Domains","text":"","category":"section"},{"location":"domains/","page":"Domains","title":"Domains","text":"A domain in Cthonios is a group of element sections and all the associated datastructures necessary to run a finite element calculation. ","category":"page"},{"location":"domains/#Index","page":"Domains","title":"Index","text":"","category":"section"},{"location":"domains/","page":"Domains","title":"Domains","text":"Modules = [Cthonios]\nPages = [\"Domains.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"domains/#Cthonios.AbstractDomain","page":"Domains","title":"Cthonios.AbstractDomain","text":"abstract type AbstractDomain\n\nAbstract base type for domains.\n\n\n\n\n\n","category":"type"},{"location":"domains/#Cthonios.Domain","page":"Domains","title":"Cthonios.Domain","text":"Domain(\n    mesh_file::String,\n    sections_in\n) -> Cthonios.Domain{C, D, S, DBCs, Vector{Int64}, NBCs, NS} where {C<:(FiniteElementContainers.VectorizedNodalField{_A, 2, _B, _C, _D} where {_A, _B, _C, _D<:AbstractVector{_A}}), D<:(DofManager{Int64, _A, _B, Vector{Float64}, _C} where {_A, _B, _C<:(AbstractArray{Int64})}), S<:NamedTuple, DBCs<:NamedTuple, NBCs<:NamedTuple, NS<:NamedTuple}\nDomain(\n    mesh_file::String,\n    sections_in,\n    dbcs_in\n) -> Cthonios.Domain{C, D, S, DBCs, Vector{Int64}, NBCs, NS} where {C<:(FiniteElementContainers.VectorizedNodalField{_A, 2, _B, _C, _D} where {_A, _B, _C, _D<:AbstractVector{_A}}), D<:(DofManager{Int64, _A, _B, Vector{Float64}, _C} where {_A, _B, _C<:(AbstractArray{Int64})}), S<:NamedTuple, DBCs<:NamedTuple, NBCs<:NamedTuple, NS<:NamedTuple}\nDomain(\n    mesh_file::String,\n    sections_in,\n    dbcs_in,\n    nbcs_in\n) -> Cthonios.Domain{C, D, S, DBCs, Vector{Int64}, NBCs, NS} where {C<:(FiniteElementContainers.VectorizedNodalField{_A, 2, _B, _C, _D} where {_A, _B, _C, _D<:AbstractVector{_A}}), D<:(DofManager{Int64, _A, _B, Vector{Float64}, _C} where {_A, _B, _C<:(AbstractArray{Int64})}), S<:NamedTuple, DBCs<:NamedTuple, NBCs<:NamedTuple, NS<:NamedTuple}\nDomain(\n    mesh_file::String,\n    sections_in,\n    dbcs_in,\n    nbcs_in,\n    contact_pairs_in\n) -> Cthonios.Domain{C, D, S, DBCs, Vector{Int64}, NBCs, NS} where {C<:(FiniteElementContainers.VectorizedNodalField{_A, 2, _B, _C, _D} where {_A, _B, _C, _D<:AbstractVector{_A}}), D<:(DofManager{Int64, _A, _B, Vector{Float64}, _C} where {_A, _B, _C<:(AbstractArray{Int64})}), S<:NamedTuple, DBCs<:NamedTuple, NBCs<:NamedTuple, NS<:NamedTuple}\n\n\nConstructor for a Domain type. mesh_file - File name of a mesh to read. sections_in - A set of Sections. dbcs_in - A set of DirichletBCs. nbcs_in - A set of NeumannBCs\n\n\n\n\n\n","category":"type"},{"location":"domains/#Cthonios.Domain-2","page":"Domains","title":"Cthonios.Domain","text":"struct Domain{C, D, S, DBCs, DDofs, NBCs, NS} <: Cthonios.AbstractDomain\n\ncoords::Any\ndof::Any\nsections::Any\ndirichlet_bcs::Any\ndirichlet_dofs::Any\nneumann_bcs::Any\nneumann_bc_sections::Any\n\nDomain type to hold information like bcs, sections, etc. Note that the DofManager unknown dofs are not automatically set. After setting up a Domain you will need to run, update_unknown_dofs!.\n\nmesh - Handle to an open FileMesh. dof - DofManager object. sections - A set of SectionInternals. dirichlet_bcs - A set of DirichletBCInternals. dirichlet_dofs - A set of dofs to apply dirichlet dofs.   This is mainly for book-keeping purposes\n\n\n\n\n\n","category":"type"},{"location":"domains/#Cthonios.DynamicAssembler-Tuple{Cthonios.Domain}","page":"Domains","title":"Cthonios.DynamicAssembler","text":"DynamicAssembler(\n    domain::Cthonios.Domain\n) -> FiniteElementContainers.DynamicAssembler{Float64, Int64, _A, _B, _C, _D, _E, _F, _G, _H, _I, _J, _K, _L, Vector{Int64}, Vector{Int64}, Vector{Float64}} where {_A<:AbstractVector{Int64}, _B<:AbstractVector{Int64}, _C<:AbstractVector{Int64}, _D<:AbstractVector{Int64}, _E<:AbstractVector{Int64}, _F<:NodalField, _G<:AbstractVector{Float64}, _H<:AbstractVector{Float64}, _I, _J, _K, _L}\n\n\nsome FEMContainers abuse\n\n\n\n\n\n","category":"method"},{"location":"domains/#Cthonios.StaticAssembler-Tuple{Cthonios.Domain}","page":"Domains","title":"Cthonios.StaticAssembler","text":"StaticAssembler(\n    domain::Cthonios.Domain\n) -> FiniteElementContainers.StaticAssembler{Float64, Int64, _A, _B, _C, _D, _E, _F, _G, _H, _I, _J, _K, Vector{Int64}, Vector{Int64}, Vector{Float64}} where {_A<:AbstractVector{Int64}, _B<:AbstractVector{Int64}, _C<:AbstractVector{Int64}, _D<:AbstractVector{Int64}, _E<:AbstractVector{Int64}, _F<:NodalField, _G<:AbstractVector{Float64}, _H, _I, _J, _K}\n\n\nsome FEMContainers abuse\n\n\n\n\n\n","category":"method"},{"location":"domains/#Cthonios.create_fields-Tuple{Cthonios.Domain}","page":"Domains","title":"Cthonios.create_fields","text":"create_fields(domain::Cthonios.Domain) -> Any\n\n\nCreate a zero field based on domain.dof.\n\n\n\n\n\n","category":"method"},{"location":"domains/#Cthonios.create_unknowns-Tuple{Cthonios.Domain}","page":"Domains","title":"Cthonios.create_unknowns","text":"create_unknowns(domain::Cthonios.Domain) -> Any\n\n\nCreates an unknown vector based on domain.dof\n\n\n\n\n\n","category":"method"},{"location":"domains/#Cthonios.dirichlet_dofs-Tuple{Cthonios.Domain}","page":"Domains","title":"Cthonios.dirichlet_dofs","text":"dirichlet_dofs(domain::Cthonios.Domain) -> Any\n\n\nReturns a sorted and unique vector of dirichlet dofs.\n\n\n\n\n\n","category":"method"},{"location":"domains/#Cthonios.update_dirichlet_vals!-Tuple{Any, Cthonios.Domain, Any, Any}","page":"Domains","title":"Cthonios.update_dirichlet_vals!","text":"update_dirichlet_vals!(Ubc, domain::Cthonios.Domain, X, t)\n\n\nUpdates the values in Ubc with dirichlet boundary conditions in domain. Ubc - BC values to fill. domain - Domain. X - Nodal coordinates. t - A scalar time value to use in the BC functions.\n\n\n\n\n\n","category":"method"},{"location":"domains/#Cthonios.update_field_bcs!-Tuple{Any, Cthonios.Domain, Any}","page":"Domains","title":"Cthonios.update_field_bcs!","text":"update_field_bcs!(U, domain::Cthonios.Domain, Ubc)\n\n\nUpdates the Dirichlet BC dofs in U with the values in Ubc. U - Nodal field to update. domain - Domain. Ubc - BC values to fill.\n\n\n\n\n\n","category":"method"},{"location":"domains/#Cthonios.update_field_unknowns!-Tuple{Any, Cthonios.Domain, Any}","page":"Domains","title":"Cthonios.update_field_unknowns!","text":"update_field_unknowns!(U, domain::Cthonios.Domain, Uu)\n\n\nUpdates the unknown dofs in U with the values in Uu. U - Nodal field to update. domain - Domain. Uu - Unknown values to fill.\n\n\n\n\n\n","category":"method"},{"location":"domains/#Cthonios.update_unknown_dofs!-Tuple{Cthonios.Domain, Any}","page":"Domains","title":"Cthonios.update_unknown_dofs!","text":"update_unknown_dofs!(domain::Cthonios.Domain, asm)\n\n\nUpdate the unknown dofs in domain.dof,  domain.dirichlet_dofs, and asm. TODO maybe move domain.dirichlet_dofsto theDofManagerinFiniteElementContainers.domain- Domain object.asm` - Assembly object.\n\n\n\n\n\n","category":"method"},{"location":"domains/#Cthonios.update_unknown_dofs!-Tuple{Cthonios.Domain}","page":"Domains","title":"Cthonios.update_unknown_dofs!","text":"update_unknown_dofs!(domain::Cthonios.Domain)\n\n\nUpdate the unknown dofs in domain.dof and domain.dirichlet_dofs. TODO maybe move domain.dirichlet_dofsto theDofManagerinFiniteElementContainers`.\n\n\n\n\n\n","category":"method"},{"location":"linear_solvers/","page":"Linear solvers","title":"Linear solvers","text":"CurrentModule = Cthonios","category":"page"},{"location":"linear_solvers/#Linear-Solvers","page":"Linear solvers","title":"Linear Solvers","text":"","category":"section"},{"location":"linear_solvers/","page":"Linear solvers","title":"Linear solvers","text":"This section describes the interface for linear solvers.","category":"page"},{"location":"linear_solvers/#Input-File-Syntax-Example","page":"Linear solvers","title":"Input File Syntax Example","text":"","category":"section"},{"location":"linear_solvers/","page":"Linear solvers","title":"Linear solvers","text":"Below is an example input file block for a direct solver with an LDLT factorization.","category":"page"},{"location":"linear_solvers/","page":"Linear solvers","title":"Linear solvers","text":"linear solvers:\n  direct:\n    type: DirectLinearSolver\n    factorization method: ldl","category":"page"},{"location":"linear_solvers/#General-methods-and-abstract-types","page":"Linear solvers","title":"General methods and abstract types","text":"","category":"section"},{"location":"linear_solvers/","page":"Linear solvers","title":"Linear solvers","text":"Modules = [Cthonios]\nPages = [\"solvers/linear_solvers/LinearSolvers.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"linear_solvers/#Cthonios.AbstractLinearSolver","page":"Linear solvers","title":"Cthonios.AbstractLinearSolver","text":"abstract type AbstractLinearSolver\n\nA linear solver simply needs to define the following methods\n\nresidual_norm\nsolve!\n\nsolve! method which has the following signature solve!(ΔUu, solver::DirectSolver, obj, Uu, p) where ΔUu is the increment for a nonlinear solver solver is the solver, obj is the objective, Uu is the current guess of the solution, and p is the set of parameters\n\n\n\n\n\n","category":"type"},{"location":"linear_solvers/#Direct-Solver","page":"Linear solvers","title":"Direct Solver","text":"","category":"section"},{"location":"linear_solvers/","page":"Linear solvers","title":"Linear solvers","text":"Modules = [Cthonios]\nPages = [\"solvers/linear_solvers/DirectSolver.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"linear_solvers/#Cthonios.DirectSolver","page":"Linear solvers","title":"Cthonios.DirectSolver","text":"assembler::Any\nlinsolve::Any\ntimer::Any\n\nDirect linear solver\n\n\n\n\n\n","category":"type"},{"location":"linear_solvers/#Cthonios.DirectSolver-Tuple{Dict{Symbol, Any}, Objective, Any, Any}","page":"Linear solvers","title":"Cthonios.DirectSolver","text":"DirectSolver(\n    inputs::Dict{Symbol, Any},\n    obj::Objective,\n    p,\n    timer\n) -> DirectSolver{A, L} where {A<:(FiniteElementContainers.StaticAssembler{Float64, Int64, _A, _B, _C, _D, _E, _F, _G, _H, _I, _J, _K, Vector{Int64}, Vector{Int64}, Vector{Float64}} where {_A<:AbstractVector{Int64}, _B<:AbstractVector{Int64}, _C<:AbstractVector{Int64}, _D<:AbstractVector{Int64}, _E<:AbstractVector{Int64}, _F<:NodalField, _G<:AbstractVector{Float64}, _H, _I, _J, _K}), L<:(LinearSolve.LinearCache{Symmetric{Float64, SparseArrays.SparseMatrixCSC{Float64, Int64}}, _A, _B, SciMLBase.NullParameters, LinearSolve.DefaultLinearSolver, LinearSolve.DefaultLinearSolverInit{LU{Float64, SparseArrays.SparseMatrixCSC{Float64, Int64}, Vector{Int64}}, QR{Float64, SparseArrays.SparseMatrixCSC{Float64, Int64}, Vector{Float64}}, Nothing, Nothing, Sparspak.SpkSparseSolver.SparseSolver{Int64, Float64}, Nothing, Nothing, _A1, LU{Float64, SparseArrays.SparseMatrixCSC{Float64, Int64}, Vector{Int64}}, Tuple{LU{Float64, SparseArrays.SparseMatrixCSC{Float64, Int64}, Vector{Int64}}, Vector{Int64}}, Nothing, Nothing, SparseArrays.CHOLMOD.Factor{Float64, Int64}, Nothing, SparseArrays.CHOLMOD.Factor{Float64, Int64}, SparseArrays.CHOLMOD.Factor{Float64, Int64}, Tuple{LU{Float64, Matrix{Float64}, Vector{Int32}}, Base.RefValue{Int32}}, Tuple{LU{Float64, Matrix{Float64}, Vector{Int64}}, Base.RefValue{Int64}}, QRPivoted{Float64, SparseArrays.SparseMatrixCSC{Float64, Int64}, Vector{Float64}, Vector{Int64}}, _B1, _C}, SciMLOperators.IdentityOperator, SciMLOperators.IdentityOperator, _C1, Bool, LinearSolve.LinearSolveAdjoint{Missing}} where {_A, _B, _A1, _B1, _C, _C1})}\n\n\nDirect linear solver constructor from a Domain\n\n\n\n\n\n","category":"method"},{"location":"linear_solvers/#Cthonios.DirectSolver-Tuple{Objective, Any, Any}","page":"Linear solvers","title":"Cthonios.DirectSolver","text":"DirectSolver(\n    obj::Objective,\n    p,\n    timer\n) -> DirectSolver{A, L} where {A<:(FiniteElementContainers.StaticAssembler{Float64, Int64, _A, _B, _C, _D, _E, _F, _G, _H, _I, _J, _K, Vector{Int64}, Vector{Int64}, Vector{Float64}} where {_A<:AbstractVector{Int64}, _B<:AbstractVector{Int64}, _C<:AbstractVector{Int64}, _D<:AbstractVector{Int64}, _E<:AbstractVector{Int64}, _F<:NodalField, _G<:AbstractVector{Float64}, _H, _I, _J, _K}), L<:(LinearSolve.LinearCache{Symmetric{Float64, SparseArrays.SparseMatrixCSC{Float64, Int64}}, _A, _B, SciMLBase.NullParameters, LinearSolve.DefaultLinearSolver, LinearSolve.DefaultLinearSolverInit{LU{Float64, SparseArrays.SparseMatrixCSC{Float64, Int64}, Vector{Int64}}, QR{Float64, SparseArrays.SparseMatrixCSC{Float64, Int64}, Vector{Float64}}, Nothing, Nothing, Sparspak.SpkSparseSolver.SparseSolver{Int64, Float64}, Nothing, Nothing, _A1, LU{Float64, SparseArrays.SparseMatrixCSC{Float64, Int64}, Vector{Int64}}, Tuple{LU{Float64, SparseArrays.SparseMatrixCSC{Float64, Int64}, Vector{Int64}}, Vector{Int64}}, Nothing, Nothing, SparseArrays.CHOLMOD.Factor{Float64, Int64}, Nothing, SparseArrays.CHOLMOD.Factor{Float64, Int64}, SparseArrays.CHOLMOD.Factor{Float64, Int64}, Tuple{LU{Float64, Matrix{Float64}, Vector{Int32}}, Base.RefValue{Int32}}, Tuple{LU{Float64, Matrix{Float64}, Vector{Int64}}, Base.RefValue{Int64}}, QRPivoted{Float64, SparseArrays.SparseMatrixCSC{Float64, Int64}, Vector{Float64}, Vector{Int64}}, _B1, _C}, SciMLOperators.IdentityOperator, SciMLOperators.IdentityOperator, _C1, Bool, LinearSolve.LinearSolveAdjoint{Missing}} where {_A, _B, _A1, _B1, _C, _C1})}\n\n\nDirect linear solver constructor from a Domain\n\n\n\n\n\n","category":"method"},{"location":"linear_solvers/#Cthonios.gradient!-Tuple{DirectSolver, Objective, Any, ObjectiveParameters}","page":"Linear solvers","title":"Cthonios.gradient!","text":"gradient!(\n    solver::DirectSolver,\n    obj::Objective,\n    Uu,\n    p::ObjectiveParameters\n)\n\n\n\n\n\n\n","category":"method"},{"location":"linear_solvers/#Cthonios.hessian!-Tuple{DirectSolver, Any, Any, Any}","page":"Linear solvers","title":"Cthonios.hessian!","text":"hessian!(solver::DirectSolver, obj, Uu, p)\n\n\n\n\n\n\n","category":"method"},{"location":"linear_solvers/#Cthonios.residual_norm-Tuple{DirectSolver, Any, Any, Any}","page":"Linear solvers","title":"Cthonios.residual_norm","text":"residual_norm(solver::DirectSolver, obj, Uu, p) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"linear_solvers/#Cthonios.solve!-Tuple{Any, DirectSolver, Any, Any, Any}","page":"Linear solvers","title":"Cthonios.solve!","text":"solve!(ΔUu, solver::DirectSolver, obj, Uu, p)\n\n\n\n\n\n\n","category":"method"},{"location":"linear_solvers/#Preconditioners","page":"Linear solvers","title":"Preconditioners","text":"","category":"section"},{"location":"linear_solvers/","page":"Linear solvers","title":"Linear solvers","text":"Modules = [Cthonios]\nPages = [\"solvers/linear_solvers/Preconditioners.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"linear_solvers/#Cthonios.AbstractPreconditioner","page":"Linear solvers","title":"Cthonios.AbstractPreconditioner","text":"abstract type AbstractPreconditioner\n\nAbstract base preconditioner type.\n\n\n\n\n\n","category":"type"},{"location":"linear_solvers/#Cthonios.CholeskyPreconditioner","page":"Linear solvers","title":"Cthonios.CholeskyPreconditioner","text":"mutable struct CholeskyPreconditioner{A, P, T} <: Cthonios.AbstractPreconditioner\n\nassembler::Any\npreconditioner::Any\ntimer::Any\n\n\n\n\n\n","category":"type"},{"location":"linear_solvers/#Cthonios.CholeskyPreconditioner-Tuple{Objective, Any, Any}","page":"Linear solvers","title":"Cthonios.CholeskyPreconditioner","text":"CholeskyPreconditioner(\n    obj::Objective,\n    p,\n    timer\n) -> CholeskyPreconditioner{A, SparseArrays.CHOLMOD.Factor{Float64, Int64}} where A<:(FiniteElementContainers.StaticAssembler{Float64, Int64, _A, _B, _C, _D, _E, _F, _G, _H, _I, _J, _K, Vector{Int64}, Vector{Int64}, Vector{Float64}} where {_A<:AbstractVector{Int64}, _B<:AbstractVector{Int64}, _C<:AbstractVector{Int64}, _D<:AbstractVector{Int64}, _E<:AbstractVector{Int64}, _F<:NodalField, _G<:AbstractVector{Float64}, _H, _I, _J, _K})\n\n\n\n\n\n\n","category":"method"},{"location":"linear_solvers/#Cthonios.LDLPreconditioner","page":"Linear solvers","title":"Cthonios.LDLPreconditioner","text":"struct LDLPreconditioner{A, P, T} <: Cthonios.AbstractPreconditioner\n\nassembler::Any\npreconditioner::Any\ntimer::Any\n\n\n\n\n\n","category":"type"},{"location":"linear_solvers/#Cthonios.LDLPreconditioner-Tuple{Objective, Any, Any}","page":"Linear solvers","title":"Cthonios.LDLPreconditioner","text":"LDLPreconditioner(\n    obj::Objective,\n    p,\n    timer\n) -> LDLPreconditioner{A, LDLFactorizations.LDLFactorization{Float64, Int64, Int64, Int64}} where A<:(FiniteElementContainers.StaticAssembler{Float64, Int64, _A, _B, _C, _D, _E, _F, _G, _H, _I, _J, _K, Vector{Int64}, Vector{Int64}, Vector{Float64}} where {_A<:AbstractVector{Int64}, _B<:AbstractVector{Int64}, _C<:AbstractVector{Int64}, _D<:AbstractVector{Int64}, _E<:AbstractVector{Int64}, _F<:NodalField, _G<:AbstractVector{Float64}, _H, _I, _J, _K})\n\n\n\n\n\n\n","category":"method"},{"location":"linear_solvers/#Cthonios.LimitedLDLPreconditioner","page":"Linear solvers","title":"Cthonios.LimitedLDLPreconditioner","text":"mutable struct LimitedLDLPreconditioner{A, P, T} <: Cthonios.AbstractPreconditioner\n\nassembler::Any\npreconditioner::Any\ntimer::Any\n\n\n\n\n\n","category":"type"},{"location":"linear_solvers/#Cthonios.LimitedLDLPreconditioner-Tuple{Objective, Any, Any}","page":"Linear solvers","title":"Cthonios.LimitedLDLPreconditioner","text":"LimitedLDLPreconditioner(\n    obj::Objective,\n    p,\n    timer\n) -> LimitedLDLPreconditioner{A, LimitedLDLFactorizations.LimitedLDLFactorization{Float64, Int64, Vector{Int64}, Vector{Int64}}} where A<:(FiniteElementContainers.StaticAssembler{Float64, Int64, _A, _B, _C, _D, _E, _F, _G, _H, _I, _J, _K, Vector{Int64}, Vector{Int64}, Vector{Float64}} where {_A<:AbstractVector{Int64}, _B<:AbstractVector{Int64}, _C<:AbstractVector{Int64}, _D<:AbstractVector{Int64}, _E<:AbstractVector{Int64}, _F<:NodalField, _G<:AbstractVector{Float64}, _H, _I, _J, _K})\n\n\n\n\n\n\n","category":"method"},{"location":"linear_solvers/#LinearAlgebra.ldiv!-Tuple{Any, CholeskyPreconditioner, Any}","page":"Linear solvers","title":"LinearAlgebra.ldiv!","text":"ldiv!(y, P::CholeskyPreconditioner, v)\n\n\n\n\n\n\n","category":"method"},{"location":"nonlinear_solvers/","page":"Nonlinear solvers","title":"Nonlinear solvers","text":"CurrentModule = Cthonios","category":"page"},{"location":"nonlinear_solvers/#Nonlinear-Solvers","page":"Nonlinear solvers","title":"Nonlinear Solvers","text":"","category":"section"},{"location":"nonlinear_solvers/","page":"Nonlinear solvers","title":"Nonlinear solvers","text":"One of our goals is to make adding new and hacking existing nonlinear solvers easy!","category":"page"},{"location":"nonlinear_solvers/#Input-File-Syntax-Example","page":"Nonlinear solvers","title":"Input File Syntax Example","text":"","category":"section"},{"location":"nonlinear_solvers/","page":"Nonlinear solvers","title":"Nonlinear solvers","text":"Below is an example input file block for a trust region solver that leverages a direct solver with an LDLT factorization. The nonlinear solver is also utilizing warm start to improve the first few iterations of each load step.","category":"page"},{"location":"nonlinear_solvers/","page":"Nonlinear solvers","title":"Nonlinear solvers","text":"linear solvers:\n  direct:\n    type: DirectLinearSolver\n    factorization method: ldl\n\nnonlinear solvers:\n  trs:\n    type: TrustRegionSolver\n    linear solver: direct\n    warm start: on","category":"page"},{"location":"nonlinear_solvers/#General-methods-and-abstract-types","page":"Nonlinear solvers","title":"General methods and abstract types","text":"","category":"section"},{"location":"nonlinear_solvers/","page":"Nonlinear solvers","title":"Nonlinear solvers","text":"Modules = [Cthonios]\nPages = [\"solvers/nonlinear_solvers/NonlinearSolvers.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"nonlinear_solvers/#Cthonios.AbstractNonlinearSolver","page":"Nonlinear solvers","title":"Cthonios.AbstractNonlinearSolver","text":"abstract type AbstractNonlinearSolver{L, O, U, W, T} <: Cthonios.AbstractSolver\n\na nonlinear solver needs to define the following methods\n\ncheck_convergence - returns a bool \nlogger - @info information\nstep! - step for the solver\n\nit needs the following types\n\na linear solver\nan objective\nan unknown vector\nan int called max_iter\n\n\n\n\n\n","category":"type"},{"location":"nonlinear_solvers/#Cthonios.solve!-Tuple{Cthonios.AbstractNonlinearSolver, Any, Any}","page":"Nonlinear solvers","title":"Cthonios.solve!","text":"solve!(solver::Cthonios.AbstractNonlinearSolver, Uu, p)\n\n\nGeneric method to fall back on if step! is defined\n\n\n\n\n\n","category":"method"},{"location":"nonlinear_solvers/#Newton-Solver","page":"Nonlinear solvers","title":"Newton Solver","text":"","category":"section"},{"location":"nonlinear_solvers/","page":"Nonlinear solvers","title":"Nonlinear solvers","text":"Modules = [Cthonios]\nPages = [\"solvers/nonlinear_solvers/NewtonSolver.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"nonlinear_solvers/#Cthonios.NewtonSolver","page":"Nonlinear solvers","title":"Cthonios.NewtonSolver","text":"struct NewtonSolver{L, O, U, W, T} <: Cthonios.AbstractNonlinearSolver{L, O, U, W, T}\n\nlinear_solver::Any\nobjective::Any\nΔUu::Any\nwarm_start::Any\ntimer::Any\nmax_iter::Int64\nabs_tol::Float64\nrel_tol::Float64\nuse_warm_start::Bool\n\n\n\n\n\n","category":"type"},{"location":"nonlinear_solvers/#Cthonios.NewtonSolver-Tuple{Dict{Symbol, Any}, Objective, Any, Any}","page":"Nonlinear solvers","title":"Cthonios.NewtonSolver","text":"NewtonSolver(\n    inputs::Dict{Symbol, Any},\n    objective::Objective,\n    p,\n    timer\n) -> NewtonSolver{_A, O, _B, W} where {_A, O<:Objective, _B, W<:Cthonios.WarmStart}\n\n\n\n\n\n\n","category":"method"},{"location":"nonlinear_solvers/#Cthonios.NewtonSolver-Tuple{Objective, Any, Any}","page":"Nonlinear solvers","title":"Cthonios.NewtonSolver","text":"NewtonSolver(\n    objective::Objective,\n    p,\n    timer;\n    linear_solver_type,\n    use_warm_start\n) -> NewtonSolver{L, O, _A, W} where {L<:(DirectSolver{A, L} where {A<:(FiniteElementContainers.StaticAssembler{Float64, Int64, _A, _B, _C, _D, _E, _F, _G, _H, _I, _J, _K, Vector{Int64}, Vector{Int64}, Vector{Float64}} where {_A<:AbstractVector{Int64}, _B<:AbstractVector{Int64}, _C<:AbstractVector{Int64}, _D<:AbstractVector{Int64}, _E<:AbstractVector{Int64}, _F<:NodalField, _G<:AbstractVector{Float64}, _H, _I, _J, _K}), L<:(LinearSolve.LinearCache{Symmetric{Float64, SparseArrays.SparseMatrixCSC{Float64, Int64}}, _A, _B, SciMLBase.NullParameters, LinearSolve.DefaultLinearSolver, LinearSolve.DefaultLinearSolverInit{LU{Float64, SparseArrays.SparseMatrixCSC{Float64, Int64}, Vector{Int64}}, QR{Float64, SparseArrays.SparseMatrixCSC{Float64, Int64}, Vector{Float64}}, Nothing, Nothing, Sparspak.SpkSparseSolver.SparseSolver{Int64, Float64}, Nothing, Nothing, _A1, LU{Float64, SparseArrays.SparseMatrixCSC{Float64, Int64}, Vector{Int64}}, Tuple{LU{Float64, SparseArrays.SparseMatrixCSC{Float64, Int64}, Vector{Int64}}, Vector{Int64}}, Nothing, Nothing, SparseArrays.CHOLMOD.Factor{Float64, Int64}, Nothing, SparseArrays.CHOLMOD.Factor{Float64, Int64}, SparseArrays.CHOLMOD.Factor{Float64, Int64}, Tuple{LU{Float64, Matrix{Float64}, Vector{Int32}}, Base.RefValue{Int32}}, Tuple{LU{Float64, Matrix{Float64}, Vector{Int64}}, Base.RefValue{Int64}}, QRPivoted{Float64, SparseArrays.SparseMatrixCSC{Float64, Int64}, Vector{Float64}, Vector{Int64}}, _B1, _C}, SciMLOperators.IdentityOperator, SciMLOperators.IdentityOperator, _C1, Bool, LinearSolve.LinearSolveAdjoint{Missing}} where {_A, _B, _A1, _B1, _C, _C1})}), O<:Objective, _A, W<:Cthonios.WarmStart}\n\n\n\n\n\n\n","category":"method"},{"location":"nonlinear_solvers/#Cthonios.check_convergence-Tuple{NewtonSolver, Any, Any, Any}","page":"Nonlinear solvers","title":"Cthonios.check_convergence","text":"check_convergence(\n    solver::NewtonSolver,\n    Uu,\n    p,\n    R0_norm\n) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"nonlinear_solvers/#Cthonios.logger-Tuple{NewtonSolver, Any, Any, Int64, Any}","page":"Nonlinear solvers","title":"Cthonios.logger","text":"logger(solver::NewtonSolver, Uu, p, n::Int64, norm_R0)\n\n\n\n\n\n\n","category":"method"},{"location":"nonlinear_solvers/#Cthonios.step!-Tuple{NewtonSolver, Any, Any}","page":"Nonlinear solvers","title":"Cthonios.step!","text":"step!(solver::NewtonSolver, Uu, p)\n\n\n\n\n\n\n","category":"method"},{"location":"nonlinear_solvers/#Trust-Region-Solver","page":"Nonlinear solvers","title":"Trust Region Solver","text":"","category":"section"},{"location":"nonlinear_solvers/","page":"Nonlinear solvers","title":"Nonlinear solvers","text":"Modules = [Cthonios]\nPages = [\"solvers/nonlinear_solvers/TrustRegionSolver.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"nonlinear_solvers/#Cthonios.TrustRegionSolver","page":"Nonlinear solvers","title":"Cthonios.TrustRegionSolver","text":"struct TrustRegionSolver{L, O, U<:(AbstractVector), W, T<:TimerOutput, F<:NodalField, S<:Cthonios.TrustRegionSolverSettings} <: Cthonios.AbstractNonlinearSolver{L, O, U<:(AbstractVector), W, T<:TimerOutput}\n\npreconditioner::Any\nobjective::Any\nΔUu::AbstractVector\nwarm_start::Any\ntimer::TimerOutput\no::AbstractVector\ng::NodalField\nHv::NodalField\ncauchy_point::AbstractVector\nq_newton_point::AbstractVector\nd::AbstractVector\ny_scratch_1::AbstractVector\ny_scratch_2::AbstractVector\ny_scratch_3::AbstractVector\ny_scratch_4::AbstractVector\nuse_warm_start::Bool\nsettings::Cthonios.TrustRegionSolverSettings\n\n\n\n\n\n","category":"type"},{"location":"nonlinear_solvers/#Cthonios.TrustRegionSolver-Tuple{Objective, Any, Any}","page":"Nonlinear solvers","title":"Cthonios.TrustRegionSolver","text":"TrustRegionSolver(\n    objective::Objective,\n    p,\n    timer;\n    preconditioner,\n    use_warm_start,\n    settings\n) -> TrustRegionSolver{L, O, Vector{Float64}, W, TimerOutput, F, Cthonios.TrustRegionSolverSettings} where {L<:(CholeskyPreconditioner{A, SparseArrays.CHOLMOD.Factor{Float64, Int64}} where A<:(FiniteElementContainers.StaticAssembler{Float64, Int64, _A, _B, _C, _D, _E, _F, _G, _H, _I, _J, _K, Vector{Int64}, Vector{Int64}, Vector{Float64}} where {_A<:AbstractVector{Int64}, _B<:AbstractVector{Int64}, _C<:AbstractVector{Int64}, _D<:AbstractVector{Int64}, _E<:AbstractVector{Int64}, _F<:NodalField, _G<:AbstractVector{Float64}, _H, _I, _J, _K})), O<:Objective, W<:Cthonios.WarmStart, F<:NodalField}\n\n\nTODO figure out which scratch arrays can be nixed\n\n\n\n\n\n","category":"method"},{"location":"nonlinear_solvers/#Cthonios.TrustRegionSolverSettings","page":"Nonlinear solvers","title":"Cthonios.TrustRegionSolverSettings","text":"t_1::Float64\nt_2::Float64\nη_1::Float64\nη_2::Float64\nη_3::Float64\nmax_trust_iters::Int64\ntol::Float64\nmax_cg_iters::Int64\nmax_cumulative_cg_iters::Int64\ncg_tol::Float64\ncg_inexact_solve_ratio::Float64\ntr_size::Float64\nmin_tr_size::Float64\ncheck_stability::Bool\nuse_preconditioned_inner_product_for_cg::Bool\nuse_incremental_objective::Bool\ndebug_info::Bool\nover_iter::Int64\n\n\n\n\n\n","category":"type"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"CurrentModule = Cthonios","category":"page"},{"location":"iterators/#Iterators","page":"Iterators","title":"Iterators","text":"","category":"section"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"Modules = [Cthonios]\nPages = [\"Iterators.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"iterators/#Cthonios.domain_iterator!-Tuple{Any, Any, Cthonios.Domain, Any, ObjectiveParameters}","page":"Iterators","title":"Cthonios.domain_iterator!","text":"domain_iterator!(\n    global_val,\n    f,\n    domain::Cthonios.Domain,\n    Uu,\n    p::ObjectiveParameters\n)\n\n\nIterator over a domain domain to fill a global value global_val based on a quadrature level function  f provided a nodal field U and set of paramaters p. This method is useful for filling quantities such as objectives, gradients, or hessians.\n\n\n\n\n\n","category":"method"},{"location":"iterators/#Cthonios.element_coordinates-Tuple{Any, Any, Any}","page":"Iterators","title":"Cthonios.element_coordinates","text":"element_coordinates(section, X, e) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"iterators/#Cthonios.element_fields-Tuple{Any, Any, Any}","page":"Iterators","title":"Cthonios.element_fields","text":"element_fields(section, U, e) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"iterators/#Cthonios.scratch_variable-Tuple{Assembler, Any}","page":"Iterators","title":"Cthonios.scratch_variable","text":"scratch_variable(global_val::Assembler, section) -> Any\n\n\nSetup a scratch variable for a stiffness like calculation\n\n\n\n\n\n","category":"method"},{"location":"iterators/#Cthonios.scratch_variable-Tuple{Vector, Any}","page":"Iterators","title":"Cthonios.scratch_variable","text":"scratch_variable(global_val::Vector, section) -> Any\n\n\nSetup a scratch variable for an energy like calculation\n\n\n\n\n\n","category":"method"},{"location":"iterators/#Cthonios.scratch_variable-Union{Tuple{T}, Tuple{T, Any}} where T<:Union{NodalField, Matrix}","page":"Iterators","title":"Cthonios.scratch_variable","text":"scratch_variable(\n    global_val::Union{NodalField, Matrix},\n    section\n) -> Any\n\n\nSetup a scratch variable for a force like calculation\n\n\n\n\n\n","category":"method"},{"location":"objectives/","page":"Objectives","title":"Objectives","text":"CurrentModule = Cthonios","category":"page"},{"location":"objectives/#Objectives","page":"Objectives","title":"Objectives","text":"","category":"section"},{"location":"objectives/","page":"Objectives","title":"Objectives","text":"Modules = [Cthonios]\nPages = [\"Objectives.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"objectives/#Cthonios.AbstractObjective","page":"Objectives","title":"Cthonios.AbstractObjective","text":"abstract type AbstractObjective\n\nAbstract base objective type.\n\n\n\n\n\n","category":"type"},{"location":"objectives/#Cthonios.AbstractObjectiveParameters","page":"Objectives","title":"Cthonios.AbstractObjectiveParameters","text":"abstract type AbstractObjectiveParameters\n\nAbstract base type for objective function parameters.\n\n\n\n\n\n","category":"type"},{"location":"objectives/#Cthonios.Objective","page":"Objectives","title":"Cthonios.Objective","text":"struct Objective{D, F1, F2, F3, F4, F5, F6, T}\n\ndomain::Any\nvalue::Any\ngradient::Any\nhessian::Any\nneumann_value::Any\nneumann_gradient::Any\nneumann_hessian::Any\ntimer::Any\n\nObjective type for evaluating objective functions. The functions correspond to quadrature level evaluations of the objective function, it's gradient, and it's hessian respectively. domain - A domain object  value - A function for the quadrature level objective function evaluation. gradient - A function for the quadrature level objective function gradient evaluation. hessian - A function for the quadrature level objective hessian evaluation. timer - A timer that's already setup.\n\n\n\n\n\n","category":"type"},{"location":"objectives/#Cthonios.ObjectiveParameters","page":"Objectives","title":"Cthonios.ObjectiveParameters","text":"struct ObjectiveParameters{U1, T, B, N, S, P, U2, U3, V1, U4, Q} <: Cthonios.AbstractObjectiveParameters\n\nX::Any\nt::Any\nUbc::Any\nnbc::Any\nstate_old::Any\nstate_new::Any\nprops::Any\nU::Any\ngrad_scratch::Any\ngrad_vec_scratch::Any\nhvp_scratch::Any\nq_vals_scratch::Any\n\nType for objective function parameters for design parameters such as coordinates, time, bc values, properties state variables, and some scratch arrays.\n\n\n\n\n\n","category":"type"},{"location":"objectives/#Cthonios.ObjectiveParameters-Tuple{Objective, Any}","page":"Objectives","title":"Cthonios.ObjectiveParameters","text":"ObjectiveParameters(\n    o::Objective,\n    times\n) -> ObjectiveParameters{_A, _B, B, N} where {_A, _B, B<:(Vector), N<:(Vector{T} where T<:(SVector{_A, _B} where {_B, _A}))}\n\n\nConstructor for a ObjectiveParameters type. o - Objective function object. times - Times object.\n\n\n\n\n\n","category":"method"},{"location":"objectives/#Cthonios.gradient!-Tuple{Any, Objective, Any, ObjectiveParameters}","page":"Objectives","title":"Cthonios.gradient!","text":"gradient!(g, o::Objective, Uu, p::ObjectiveParameters)\n\n\n\n\n\n\n","category":"method"},{"location":"objectives/#Cthonios.hessian!-Tuple{Assembler, Objective, Any, ObjectiveParameters}","page":"Objectives","title":"Cthonios.hessian!","text":"hessian!(\n    asm::Assembler,\n    o::Objective,\n    Uu,\n    p::ObjectiveParameters\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"objectives/#Cthonios.hvp!-Tuple{AbstractVector, Objective, Any, ObjectiveParameters, Any}","page":"Objectives","title":"Cthonios.hvp!","text":"hvp!(\n    Hv::AbstractVector,\n    o::Objective,\n    Uu,\n    p::ObjectiveParameters,\n    Vv\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"objectives/#Cthonios.hvp!-Tuple{NodalField, Objective, Any, ObjectiveParameters, Any}","page":"Objectives","title":"Cthonios.hvp!","text":"hvp!(\n    Hv::NodalField,\n    o::Objective,\n    Uu,\n    p::ObjectiveParameters,\n    Vv\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"objectives/#Cthonios.objective!-Tuple{Any, Objective, Any, ObjectiveParameters}","page":"Objectives","title":"Cthonios.objective!","text":"objective!(\n    val,\n    o::Objective,\n    Uu,\n    p::ObjectiveParameters\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"objectives/#Cthonios.step!-Tuple{ObjectiveParameters}","page":"Objectives","title":"Cthonios.step!","text":"step!(p::ObjectiveParameters)\n\n\n\n\n\n\n","category":"method"},{"location":"objectives/#Cthonios.update_dirichlet_vals!-Tuple{ObjectiveParameters, Objective}","page":"Objectives","title":"Cthonios.update_dirichlet_vals!","text":"update_dirichlet_vals!(p::ObjectiveParameters, o::Objective)\n\n\n\n\n\n\n","category":"method"},{"location":"objectives/#Cthonios.update_neumann_vals!-Tuple{ObjectiveParameters, Objective}","page":"Objectives","title":"Cthonios.update_neumann_vals!","text":"update_neumann_vals!(p::ObjectiveParameters, o::Objective)\n\n\n\n\n\n\n","category":"method"},{"location":"bcs/#Boundary-Conditions","page":"Boundary Conditions","title":"Boundary Conditions","text":"","category":"section"},{"location":"bcs/#Abstract-Types","page":"Boundary Conditions","title":"Abstract Types","text":"","category":"section"},{"location":"bcs/","page":"Boundary Conditions","title":"Boundary Conditions","text":"There is currently only a loose set of abstract types to define BCs. TODO","category":"page"},{"location":"bcs/","page":"Boundary Conditions","title":"Boundary Conditions","text":"Modules = [Cthonios]\nPages = [\"bcs/BoundaryConditions.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"bcs/#Cthonios.AbstractBCInput","page":"Boundary Conditions","title":"Cthonios.AbstractBCInput","text":"abstract type AbstractBCInput\n\n\n\n\n\n","category":"type"},{"location":"bcs/#Cthonios.AbstractBCInternal","page":"Boundary Conditions","title":"Cthonios.AbstractBCInternal","text":"abstract type AbstractBCInternal\n\n\n\n\n\n","category":"type"},{"location":"bcs/#Dirichlet-BCs","page":"Boundary Conditions","title":"Dirichlet BCs","text":"","category":"section"},{"location":"bcs/","page":"Boundary Conditions","title":"Boundary Conditions","text":"Dirichlet BCs are defined in a general way where each DirichletBC acts on a collection of nodes and a collection of dof indices.","category":"page"},{"location":"bcs/","page":"Boundary Conditions","title":"Boundary Conditions","text":"We can set up a Dirichlet BC in a script with syntax similar to the following","category":"page"},{"location":"bcs/","page":"Boundary Conditions","title":"Boundary Conditions","text":"using Cthonios\nbc = DirichletBC(\"nset\", [1], (x, t) -> 0.0)\n\n# output\nDirichletBC:\n  Node set = nset\n  Dofs     = [1]\n  Function = #1","category":"page"},{"location":"bcs/","page":"Boundary Conditions","title":"Boundary Conditions","text":"In general, problems will have a collection of Dirichlet BCs which can be set up as follows","category":"page"},{"location":"bcs/","page":"Boundary Conditions","title":"Boundary Conditions","text":"using Cthonios\ndbcs = [\n  DirichletBC(\"nset_1\", [1, 2], (x, t) -> 0.0)\n  DirichletBC(\"nset_2\", [1], (x, t) -> 0.0)\n  DirichletBC(\"nset_2\", [2], (x, t) -> 1.0)\n]\n\n# output\n3-element Vector{DirichletBC{String, Vector{Int64}}}:\n DirichletBC:\n  Node set = nset_1\n  Dofs     = [1, 2]\n  Function = #1\n\n DirichletBC:\n  Node set = nset_2\n  Dofs     = [1]\n  Function = #2\n\n DirichletBC:\n  Node set = nset_2\n  Dofs     = [2]\n  Function = #3\n","category":"page"},{"location":"bcs/","page":"Boundary Conditions","title":"Boundary Conditions","text":"Internally these types defined in a script will be converted to a new type DirichletBCInternal which will read quantities off of the input mesh. This allows for BC definition prior to mesh reading so error checking can be done more efficiently.","category":"page"},{"location":"bcs/","page":"Boundary Conditions","title":"Boundary Conditions","text":"Modules = [Cthonios]\nPages = [\"bcs/DirichletBC.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"bcs/#Cthonios.DirichletBC","page":"Boundary Conditions","title":"Cthonios.DirichletBC","text":"struct DirichletBC{N, D, F} <: Cthonios.AbstractBCInput\n\nnset_name::Any\ndofs::Any\nfunc::Any\n\nBase Dirichlet boundary condition type used  for inputs either from a script or input file.  nset_name corresponds to the name of the  node set in the exodus file, dofs correspond to the indexed fields this bc is to be applied to, and func is the function to apply to the fields.\n\n\n\n\n\n","category":"type"},{"location":"bcs/#Cthonios.DirichletBC-Tuple{Dict{Symbol, Any}}","page":"Boundary Conditions","title":"Cthonios.DirichletBC","text":"DirichletBC(\n    inputs::Dict{Symbol, Any}\n) -> DirichletBC{_A, _B, F} where {_A, _B, F<:RuntimeGeneratedFunctions.RuntimeGeneratedFunction}\n\n\nInput file syntax\n\ndomain:\n  dirichlet boundary conditions:\n  - type: DirichletBC\n    nodeset: nset_1\n    function: (x, t) -> 0.0\n  - type: DirichletBC\n    nodeset: nset_2\n    function: (x, t) -> 1.0\n  ...\n\n\n\n\n\n","category":"method"},{"location":"bcs/#Cthonios.DirichletBCInternal","page":"Boundary Conditions","title":"Cthonios.DirichletBCInternal","text":"struct DirichletBCInternal{N, D, F} <: Cthonios.AbstractBCInternal\n\nnodes::Any\ndofs::Any\nfunc::Any\n\nBase internal Dirichlet boundary condition used for internal purposes. nodes corresponds to the node ids this BC is to be applied to, dofs is the set of degrees of freedoms this bc  is to be applied to, and func is the function to apply to a field on the dofs.\n\n\n\n\n\n","category":"type"},{"location":"bcs/#Cthonios.DirichletBCInternal-Tuple{Any, DirichletBC, Int64}","page":"Boundary Conditions","title":"Cthonios.DirichletBCInternal","text":"DirichletBCInternal(\n    mesh,\n    bc::DirichletBC,\n    n_dofs::Int64\n) -> Cthonios.DirichletBCInternal{_A, Vector{Int64}} where _A\n\n\nConstructor for internal Dirichlet boundary condition. mesh is the exodus mesh to read node sets from, bc is the DirichletBC input, and n_dofs is the total number of fields in the problem.\n\n\n\n\n\n","category":"method"},{"location":"bcs/#Cthonios.setup_bcs-Tuple{Type{Cthonios.DirichletBCInternal}, Any, Any, Any}","page":"Boundary Conditions","title":"Cthonios.setup_bcs","text":"setup_bcs(\n    _::Type{Cthonios.DirichletBCInternal},\n    mesh,\n    dbcs_in,\n    n_dofs\n) -> NamedTuple\n\n\n\n\n\n\n","category":"method"},{"location":"bcs/#Neumann-BCs","page":"Boundary Conditions","title":"Neumann BCs","text":"","category":"section"},{"location":"bcs/","page":"Boundary Conditions","title":"Boundary Conditions","text":"Neumann BCs are nearly identical to Dirichlet BCs in terms of script inputs except these BCs do not require a set of dofs. One can define a NeumannBC as follows","category":"page"},{"location":"bcs/","page":"Boundary Conditions","title":"Boundary Conditions","text":"using Cthonios\nbc = NeumannBC(\"sset\", (x, t) -> @SVector [0., 1.])\n\n# output\nNeumannBC:\n  Side set = sset\n  Function = #1","category":"page"},{"location":"bcs/","page":"Boundary Conditions","title":"Boundary Conditions","text":"Collections of NeumannBCs follows identically to collections of DirichletBCs.","category":"page"},{"location":"bcs/","page":"Boundary Conditions","title":"Boundary Conditions","text":"Modules = [Cthonios]\nPages = [\"bcs/NeumannBC.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"bcs/#Cthonios.NeumannBC","page":"Boundary Conditions","title":"Cthonios.NeumannBC","text":"struct NeumannBC{S, F} <: Cthonios.AbstractBCInput\n\nsset_name::Any\nfunc::Any\n\n\n\n\n\n","category":"type"},{"location":"bcs/#Cthonios.NeumannBC-Tuple{Dict{Symbol, Any}}","page":"Boundary Conditions","title":"Cthonios.NeumannBC","text":"NeumannBC(\n    inputs::Dict{Symbol, Any}\n) -> NeumannBC{_A, F} where {_A, F<:RuntimeGeneratedFunctions.RuntimeGeneratedFunction}\n\n\n\n\n\n\n","category":"method"},{"location":"bcs/#Cthonios.NeumannBCInternal","page":"Boundary Conditions","title":"Cthonios.NeumannBCInternal","text":"struct NeumannBCInternal{E, S, F} <: Cthonios.AbstractBCInternal\n\nelements::Any\nsides::Any\nnum_nodes_per_side::Any\nside_nodes::Any\nfunc::Any\n\n\n\n\n\n","category":"type"},{"location":"bcs/#Cthonios.NeumannBCInternal-Tuple{Any, NeumannBC}","page":"Boundary Conditions","title":"Cthonios.NeumannBCInternal","text":"NeumannBCInternal(\n    mesh,\n    bc::NeumannBC\n) -> Cthonios.NeumannBCInternal\n\n\n\n\n\n\n","category":"method"},{"location":"bcs/#Cthonios.setup_bcs-Tuple{Type{Cthonios.NeumannBCInternal}, Any, Any, Any}","page":"Boundary Conditions","title":"Cthonios.setup_bcs","text":"setup_bcs(\n    _::Type{Cthonios.NeumannBCInternal},\n    mesh,\n    nbcs_in,\n    sections_in\n) -> NamedTuple\n\n\n\n\n\n\n","category":"method"},{"location":"physics/#Physics","page":"Physics","title":"Physics","text":"","category":"section"},{"location":"physics/#General-methods-and-abstract-types","page":"Physics","title":"General methods and abstract types","text":"","category":"section"},{"location":"physics/","page":"Physics","title":"Physics","text":"Modules = [Cthonios]\nPages = [\"physics/Physics.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"physics/#Cthonios.AbstractPhysics","page":"Physics","title":"Cthonios.AbstractPhysics","text":"abstract type AbstractPhysics{NF, NP, NS}\n\nNF - Number of fields in this physics\n\nNP - Number of properties in this physics\n\nNS - Number of states in this physics\n\n\n\n\n\n","category":"type"},{"location":"physics/#Cthonios.num_fields-Union{Tuple{Cthonios.AbstractPhysics{NF, NP, NS}}, Tuple{NS}, Tuple{NP}, Tuple{NF}} where {NF, NP, NS}","page":"Physics","title":"Cthonios.num_fields","text":"num_fields(_::Cthonios.AbstractPhysics{NF, NP, NS}) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"physics/#Cthonios.num_properties-Union{Tuple{Cthonios.AbstractPhysics{NF, NP, NS}}, Tuple{NS}, Tuple{NP}, Tuple{NF}} where {NF, NP, NS}","page":"Physics","title":"Cthonios.num_properties","text":"num_properties(\n    _::Cthonios.AbstractPhysics{NF, NP, NS}\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"physics/#Cthonios.num_states-Union{Tuple{Cthonios.AbstractPhysics{NF, NP, NS}}, Tuple{NS}, Tuple{NP}, Tuple{NF}} where {NF, NP, NS}","page":"Physics","title":"Cthonios.num_states","text":"num_states(_::Cthonios.AbstractPhysics{NF, NP, NS}) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"physics/#Cthonios.reshape_field-Tuple{Cthonios.AbstractPhysics, Any, Any}","page":"Physics","title":"Cthonios.reshape_field","text":"comes in as (Nnodes x nfields) vector returns as nfields x nnodes matrix\n\n\n\n\n\n","category":"method"},{"location":"physics/#Lagrangian-Solid-Mechanics","page":"Physics","title":"Lagrangian Solid Mechanics","text":"","category":"section"},{"location":"physics/","page":"Physics","title":"Physics","text":"Modules = [Cthonios]\nPages = [\"physics/SolidMechanics.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"physics/#Cthonios.SolidMechanics","page":"Physics","title":"Cthonios.SolidMechanics","text":"struct SolidMechanics{NF, NP, NS, Mat, Form, P<:Cthonios.StressDivergence{NF, NP, NS, Mat, Form}} <: Cthonios.AbstractPhysics{NF, NP, NS}\n\nmaterial_model::Any\nformulation::Any\nstress_divergence::Cthonios.StressDivergence{NF, NP, NS, Mat, Form} where {NF, NP, NS, Mat, Form}\n\n\n\n\n\n","category":"type"},{"location":"physics/#Cthonios.energy-Union{Tuple{T}, Tuple{SolidMechanics, T, Vararg{Any, 5}}} where T<:AbstractArray","page":"Physics","title":"Cthonios.energy","text":"energy(\n    physics::SolidMechanics,\n    u::AbstractArray,\n    ∇u,\n    X,\n    t,\n    Z,\n    props\n) -> Any\n\n\nEnergy method at the quadrature level for Lagrangian solid mechanics. This equivalent to the quadrature point calculation needed for the  following integral Pi = int_Omegapsileft(mathbfFright)dOmega\n\n\n\n\n\n","category":"method"},{"location":"physics/#Cthonios.gradient-Tuple{SolidMechanics, Vararg{Any, 8}}","page":"Physics","title":"Cthonios.gradient","text":"gradient(\n    physics::SolidMechanics,\n    u,\n    ∇u,\n    v,\n    ∇v,\n    X,\n    t,\n    Z,\n    props\n) -> Any\n\n\nGradient method at the quadrature level for Lagrangian solid mechanics. This equivalent to the quadrature point calculation needed for the  following integral mathbff = int_OmegamathbfPdeltamathbfFdOmega\n\n\n\n\n\n","category":"method"},{"location":"physics/#Cthonios.hessian-Tuple{SolidMechanics, Vararg{Any, 8}}","page":"Physics","title":"Cthonios.hessian","text":"hessian(\n    physics::SolidMechanics,\n    u,\n    ∇u,\n    v,\n    ∇v,\n    X,\n    t,\n    Z,\n    props\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"physics/#Poisson","page":"Physics","title":"Poisson","text":"","category":"section"},{"location":"physics/","page":"Physics","title":"Physics","text":"Modules = [Cthonios]\nPages = [\"physics/Poisson.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"physics/#Cthonios.Poisson","page":"Physics","title":"Cthonios.Poisson","text":"struct Poisson{Form, S} <: Cthonios.AbstractPhysics{1, 0, 0}\n\nformulation::Any\nlaplacian::Cthonios.Laplacian{1}\nsource::Any\n\nTODO create source term kernel\n\n\n\n\n\n","category":"type"},{"location":"physics/#Cthonios.energy-Union{Tuple{T}, Tuple{Poisson, T, Vararg{Any, 5}}} where T<:AbstractArray","page":"Physics","title":"Cthonios.energy","text":"energy(\n    physics::Poisson,\n    u::AbstractArray,\n    ∇u,\n    X,\n    t,\n    Z,\n    props\n) -> Any\n\n\nEnergy method for Poisson equation at a quadrature point Pilefturight = int_Omega leftfrac12nabla u^2 - furightdOmega\n\n\n\n\n\n","category":"method"},{"location":"physics/#Cthonios.gradient-Tuple{Poisson, Vararg{Any, 8}}","page":"Physics","title":"Cthonios.gradient","text":"gradient(\n    physics::Poisson,\n    u,\n    ∇u,\n    v,\n    ∇v,\n    X,\n    t,\n    Z,\n    props\n) -> Any\n\n\nGradient method for Poisson equation at a quadrature point gleft(u vright) = int_Omega leftnabla ucdotnabla v - fvrightdOmega\n\n\n\n\n\n","category":"method"},{"location":"physics/#Cthonios.hessian-Tuple{Poisson, Vararg{Any, 8}}","page":"Physics","title":"Cthonios.hessian","text":"hessian(\n    physics::Poisson,\n    u,\n    ∇u,\n    v,\n    ∇v,\n    X,\n    t,\n    Z,\n    props\n) -> Any\n\n\nHessian method for Poisson equation at a quadrature point Hleft(u vright) = int_Omega leftnabla vcdotnabla vrightdOmega\n\n\n\n\n\n","category":"method"},{"location":"running_cthonios/","page":"Running Cthonios","title":"Running Cthonios","text":"CurrentModule = Cthonios","category":"page"},{"location":"running_cthonios/#Running-from-the-REPL","page":"Running Cthonios","title":"Running from the REPL","text":"","category":"section"},{"location":"running_cthonios/","page":"Running Cthonios","title":"Running Cthonios","text":"To run Cthonios from the REPL one can proceed in one of two manners. Either you can write your input to Cthonios as a julia script (e.g. script.jl) or you can provide input via our yaml input file.","category":"page"},{"location":"running_cthonios/","page":"Running Cthonios","title":"Running Cthonios","text":"The script approach can proceed with the following recipe","category":"page"},{"location":"running_cthonios/","page":"Running Cthonios","title":"Running Cthonios","text":"using Revise, Cthonios\ninclude(\"script.jl\")","category":"page"},{"location":"running_cthonios/","page":"Running Cthonios","title":"Running Cthonios","text":"The input file approach can proceed with the following recipe","category":"page"},{"location":"running_cthonios/","page":"Running Cthonios","title":"Running Cthonios","text":"using Revise, Cthonios\npush!(ARGS, \"-i\")\npush!(ARGS, \"input_file.yaml\")\nCthonios.cthonios_main()","category":"page"},{"location":"running_cthonios/","page":"Running Cthonios","title":"Running Cthonios","text":"Of course one can just run the following from a terminal","category":"page"},{"location":"running_cthonios/","page":"Running Cthonios","title":"Running Cthonios","text":"julia script.jl","category":"page"},{"location":"running_cthonios/","page":"Running Cthonios","title":"Running Cthonios","text":"but this will re-compile certain features of the code for each run which is not great for de-bugging a new problem.","category":"page"},{"location":"running_cthonios/#Running-Cthonios-as-an-executable","page":"Running Cthonios","title":"Running Cthonios as an executable","text":"","category":"section"},{"location":"running_cthonios/","page":"Running Cthonios","title":"Running Cthonios","text":"To run Cthonios as an executable, one must first run the CthoniosBuild.jl script (assuming one has PackageCompiler installed already). This will build an executable called cthonios in a build folder. This script has several options and we suggest running ","category":"page"},{"location":"running_cthonios/","page":"Running Cthonios","title":"Running Cthonios","text":"julia --project=@. CthoniosBuild.jl -h","category":"page"},{"location":"running_cthonios/","page":"Running Cthonios","title":"Running Cthonios","text":"prior to proceeding with an executable.","category":"page"},{"location":"running_cthonios/","page":"Running Cthonios","title":"Running Cthonios","text":"To run Cthonios as an executable you can use the following command (after building of course)","category":"page"},{"location":"running_cthonios/","page":"Running Cthonios","title":"Running Cthonios","text":"/path/to/cthonios -i <input-file.yaml>","category":"page"},{"location":"running_cthonios/","page":"Running Cthonios","title":"Running Cthonios","text":"See the examples folder for input file examples. Please note that input file syntax will usually lag behind newly implemented capabilites since we do not strictly enforce each feature to implement yaml parsing currently.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = Cthonios","category":"page"},{"location":"#Cthonios","page":"Home","title":"Cthonios","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: Stable) (Image: Dev) (Image: Build Status) (Image: Coverage) (Image: PkgEval)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Cthonios - Continuum THermodynamic Optimization-based Numerical Implementations Of Solid mechanics","category":"page"},{"location":"","page":"Home","title":"Home","text":"This is a collection of tools for solving solid mechanics problems via optimization methods. This is larrgely inspired by the python package OptimiSM.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The tools build on several other packages such as Exodus.jl, ReferenceFiniteElements.jl, FiniteElementContainers.jl, and ConstitutiveModels.jl to name a few of the direct dependencies developed by the Cthonios organization.","category":"page"},{"location":"time_steppers/","page":"Time steppers","title":"Time steppers","text":"CurrentModule = Cthonios","category":"page"},{"location":"time_steppers/#Time-steppers","page":"Time steppers","title":"Time steppers","text":"","category":"section"},{"location":"time_steppers/","page":"Time steppers","title":"Time steppers","text":"Modules = [Cthonios]\nPages = [\"TimeSteppers.jl\"]\nOrder = [:type, :function]","category":"page"}]
}
